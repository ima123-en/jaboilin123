local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local UserInputService = game:GetService("UserInputService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local LocalPlayer = Players.LocalPlayer

local Packages = ReplicatedStorage:WaitForChild("Packages")
local Datas = ReplicatedStorage:WaitForChild("Datas")
local Shared = ReplicatedStorage:WaitForChild("Shared")
local Utils = ReplicatedStorage:WaitForChild("Utils")

local Synchronizer = require(Packages:WaitForChild("Synchronizer"))
local AnimalsData = require(Datas:WaitForChild("Animals"))
local AnimalsShared = require(Shared:WaitForChild("Animals"))
local NumberUtils = require(Utils:WaitForChild("NumberUtils"))

local TweenToSpeed = 57
local WalkSpeed = 29
local WalkSpeedSlow = 28
local SlowSpeedDuration = 0.4
local StandStillDuration = -1
local DodgeSpeed = 29
local DodgeRadius = 28
local DodgeDuration = 0.22
local DodgeCooldown = 0.25
local DodgeStartDelay = 0.6
local DodgePredictionTime = 0.4
local STEAL_DURATION = 0.9
local AUTO_GRAB_DISTANCE = 41
local WAYPOINT_REACH_DIST = 3
local FINAL_WAYPOINT_REACH_DIST = 0.5

local IsRunning = false
local IsDodging = false
local DodgeStartTime = 0
local LastDodgeEndTime = 0
local CurrentDodgeDirection = nil
local LastHealth = 100
local Connection = nil
local ToBaseStartTime = 0
local GrabFinishedTime = 0
local CurrentPhase = "Idle"
local CurrentWaypointIndex = 1
local AllWaypoints = {}
local IsStealing = false
local StealProgress = 0
local StealStartTime = 0
local StealStarted = false
local StealFinished = false
local StealFinishTime = 0
local CurrentStealPrompt = nil
local InternalStealCache = {}
local PromptMemoryCache = {}
local allAnimalsCache = {}
local plotChannels = {}
local lastAnimalData = {}
local TargetAnimalData = nil
local TotalPathDistance = 0
local HasTransitionedToBase = false
local ReachedFinalWaypoint = false

-- PATH 1: Look Direction bei Start
local LookDirection1 = Vector3.new(-0.03, 0.00, -1.00)
local BrainrotPath1 = {
    Vector3.new(-476.67, -6.62, 92.66),
}
local FinalPath1 = {
    Vector3.new(-483.26, -5.34, 94.71)
}

-- PATH 2: Look Direction bei Start
local LookDirection2 = Vector3.new(-0.01, -0.00, 1.00)
local BrainrotPath2 = {
    Vector3.new(-476.13, -6.84, 25.61),
}
local FinalPath2 = {
    Vector3.new(-483.07, -5.40, 23.01)
}

local BasePath1 = {
    Vector3.new(-484.70, -8.24, 96.42),
    Vector3.new(-473.36, -10.30, 97.25),
    Vector3.new(-471.63, -9.90, 9.36),
}

local BasePath2 = {
    Vector3.new(-484.27, -8.40, 21.12),
    Vector3.new(-473.06, -10.30, 21.38),
    Vector3.new(-471.08, -9.84, 117.21),
}

local function getHRP()
    local char = LocalPlayer.Character
    if not char then return nil end
    return char:FindFirstChild("HumanoidRootPart")
end

local function SetLookDirection(hrp, lookVector)
    if not hrp or not lookVector then return end
    local pos = hrp.Position
    local targetPos = pos + lookVector * 10
    hrp.CFrame = CFrame.new(pos, Vector3.new(targetPos.X, pos.Y, targetPos.Z))
end

local function isMyBase(plotName)
    local plots = Workspace:FindFirstChild("Plots")
    if not plots then return false end
    local plot = plots:FindFirstChild(plotName)
    if not plot then return false end
    local channel = Synchronizer:Get(plot.Name)
    if channel then
        local owner = channel:Get("Owner")
        if owner then
            if typeof(owner) == "Instance" and owner:IsA("Player") then
                return owner.UserId == LocalPlayer.UserId
            elseif typeof(owner) == "table" and owner.UserId then
                return owner.UserId == LocalPlayer.UserId
            end
        end
    end
    local sign = plot:FindFirstChild("PlotSign")
    if sign then
        local yourBase = sign:FindFirstChild("YourBase")
        if yourBase and yourBase:IsA("BillboardGui") then
            return yourBase.Enabled == true
        end
    end
    return false
end

local function GetMyPlot()
    local plots = Workspace:FindFirstChild("Plots")
    if not plots then return nil end
    for _, plot in pairs(plots:GetChildren()) do
        if isMyBase(plot.Name) then
            return plot
        end
    end
    return nil
end

local function getAnimalHash(animalList)
    if not animalList then return "" end
    local hash = ""
    for slot, data in pairs(animalList) do
        if type(data) == "table" then
            hash = hash .. tostring(slot) .. tostring(data.Index) .. tostring(data.Mutation)
        end
    end
    return hash
end

local function scanSinglePlot(plot)
    pcall(function()
        local plotUID = plot.Name
        if isMyBase(plotUID) then return end
        local channel = Synchronizer:Get(plotUID)
        if not channel then return end
        local animalList = channel:Get("AnimalList")
        local currentHash = getAnimalHash(animalList)
        if lastAnimalData[plotUID] == currentHash then return end
        lastAnimalData[plotUID] = currentHash
        for i = #allAnimalsCache, 1, -1 do
            if allAnimalsCache[i].plot == plot.Name then
                table.remove(allAnimalsCache, i)
            end
        end
        local owner = channel:Get("Owner")
        if not owner or not Players:FindFirstChild(owner.Name) then return end
        local ownerName = owner and owner.Name or "Unknown"
        if not animalList then return end
        for slot, animalData in pairs(animalList) do
            if type(animalData) == "table" then
                local animalName = animalData.Index
                local animalInfo = AnimalsData[animalName]
                if not animalInfo then continue end
                local mutation = animalData.Mutation or "None"
                local genValue = AnimalsShared:GetGeneration(animalName, animalData.Mutation, animalData.Traits, nil)
                local podiums = plot:FindFirstChild("AnimalPodiums")
                local worldPos = nil
                if podiums then
                    local podium = podiums:FindFirstChild(tostring(slot))
                    if podium then
                        worldPos = podium:GetPivot().Position
                    end
                end
                table.insert(allAnimalsCache, {
                    name = animalInfo.DisplayName or animalName,
                    genValue = genValue,
                    mutation = mutation,
                    owner = ownerName,
                    plot = plot.Name,
                    slot = tostring(slot),
                    uid = plot.Name .. "_" .. tostring(slot),
                    worldPosition = worldPos,
                })
            end
        end
        table.sort(allAnimalsCache, function(a, b)
            return a.genValue > b.genValue
        end)
    end)
end

local function scanAllPlots()
    local plots = Workspace:FindFirstChild("Plots")
    if not plots then return end
    for _, plot in ipairs(plots:GetChildren()) do
        scanSinglePlot(plot)
    end
end

local function findProximityPromptForAnimal(animalData)
    if not animalData then return nil end
    local cachedPrompt = PromptMemoryCache[animalData.uid]
    if cachedPrompt and cachedPrompt.Parent then
        return cachedPrompt
    end
    local plot = Workspace.Plots:FindFirstChild(animalData.plot)
    if not plot then return nil end
    local podiums = plot:FindFirstChild("AnimalPodiums")
    if not podiums then return nil end
    local podium = podiums:FindFirstChild(animalData.slot)
    if not podium then return nil end
    local base = podium:FindFirstChild("Base")
    if not base then return nil end
    local spawn = base:FindFirstChild("Spawn")
    if not spawn then return nil end
    local attach = spawn:FindFirstChild("PromptAttachment")
    if not attach then return nil end
    for _, p in ipairs(attach:GetChildren()) do
        if p:IsA("ProximityPrompt") then
            PromptMemoryCache[animalData.uid] = p
            return p
        end
    end
    return nil
end

local function buildStealCallbacks(prompt)
    if InternalStealCache[prompt] then return true end
    local data = {
        holdCallbacks = {},
        triggerCallbacks = {},
        ready = true,
    }
    local ok1, conns1 = pcall(getconnections, prompt.PromptButtonHoldBegan)
    if ok1 and type(conns1) == "table" then
        for _, conn in ipairs(conns1) do
            if type(conn.Function) == "function" then
                table.insert(data.holdCallbacks, conn.Function)
            end
        end
    end
    local ok2, conns2 = pcall(getconnections, prompt.Triggered)
    if ok2 and type(conns2) == "table" then
        for _, conn in ipairs(conns2) do
            if type(conn.Function) == "function" then
                table.insert(data.triggerCallbacks, conn.Function)
            end
        end
    end
    if (#data.holdCallbacks > 0) or (#data.triggerCallbacks > 0) then
        InternalStealCache[prompt] = data
        return true
    end
    return false
end

local function prebuildAllCallbacks()
    for _, animalData in ipairs(allAnimalsCache) do
        local prompt = findProximityPromptForAnimal(animalData)
        if prompt then
            buildStealCallbacks(prompt)
        end
    end
end

local function cancelCurrentSteal()
    if CurrentStealPrompt and InternalStealCache[CurrentStealPrompt] then
        InternalStealCache[CurrentStealPrompt].ready = true
    end
    IsStealing = false
    StealProgress = 0
    StealStarted = false
    StealFinished = false
    StealStartTime = 0
    StealFinishTime = 0
    CurrentStealPrompt = nil
end

local function executeInstantSteal(prompt)
    if not prompt or not prompt.Parent then return false end
    if not buildStealCallbacks(prompt) then return false end
    local data = InternalStealCache[prompt]
    if not data or not data.ready then return false end
    data.ready = false
    IsStealing = true
    StealProgress = 0
    StealStartTime = tick()
    StealFinished = false
    CurrentStealPrompt = prompt
    if #data.holdCallbacks > 0 then
        for _, fn in ipairs(data.holdCallbacks) do
            task.spawn(fn)
        end
    end
    return true
end

local function finishSteal()
    if not CurrentStealPrompt then return end
    local data = InternalStealCache[CurrentStealPrompt]
    if not data then return end
    if #data.triggerCallbacks > 0 then
        for _, fn in ipairs(data.triggerCallbacks) do
            task.spawn(fn)
        end
    end
    StealFinished = true
    StealFinishTime = tick()
    task.delay(0.05, function()
        if data then data.ready = true end
    end)
    task.delay(0.1, function()
        IsStealing = false
        StealProgress = 0
        CurrentStealPrompt = nil
    end)
end

local function getBestAnimal()
    if #allAnimalsCache == 0 then return nil end
    for _, animal in ipairs(allAnimalsCache) do
        if not isMyBase(animal.plot) then
            return animal
        end
    end
    return nil
end

local function getDistanceToTarget(hrp)
    if not TargetAnimalData or not TargetAnimalData.worldPosition then return math.huge end
    local diff = TargetAnimalData.worldPosition - hrp.Position
    return Vector3.new(diff.X, 0, diff.Z).Magnitude
end

local function GetMyAnimalTarget()
    local myPlot = GetMyPlot()
    if not myPlot then return nil end
    local animalTarget = myPlot:FindFirstChild("AnimalTarget")
    if animalTarget and animalTarget:IsA("BasePart") then
        return animalTarget.Position
    end
    return nil
end

local ChosenLookDirection = nil

local function ChooseBrainrotPath(brainrotPos)
    if not brainrotPos then 
        ChosenLookDirection = LookDirection1
        return BrainrotPath1, FinalPath1 
    end
    local dist1 = (FinalPath1[#FinalPath1] - brainrotPos).Magnitude
    local dist2 = (FinalPath2[#FinalPath2] - brainrotPos).Magnitude
    if dist1 < dist2 then
        ChosenLookDirection = LookDirection1
        return BrainrotPath1, FinalPath1
    else
        ChosenLookDirection = LookDirection2
        return BrainrotPath2, FinalPath2
    end
end

local function ChooseBasePath(basePos)
    if not basePos then return BasePath1 end
    local dist1 = (BasePath1[#BasePath1] - basePos).Magnitude
    local dist2 = (BasePath2[#BasePath2] - basePos).Magnitude
    return dist1 < dist2 and BasePath1 or BasePath2
end

local function GetAllThreats(hrp)
    local threats = {}
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            local otherHrp = player.Character:FindFirstChild("HumanoidRootPart")
            if otherHrp then
                local distance = (hrp.Position - otherHrp.Position).Magnitude
                if distance <= DodgeRadius then
                    local vel = otherHrp.AssemblyLinearVelocity
                    table.insert(threats, {
                        hrp = otherHrp,
                        distance = distance,
                        velocity = vel,
                        predictedPos = otherHrp.Position + Vector3.new(vel.X, 0, vel.Z) * DodgePredictionTime,
                    })
                end
            end
        end
    end
    return threats
end

local function ShouldDodge(hrp, threats)
    for _, threat in ipairs(threats) do
        local toMe = hrp.Position - threat.hrp.Position
        toMe = Vector3.new(toMe.X, 0, toMe.Z)
        if toMe.Magnitude < 0.1 then continue end
        toMe = toMe.Unit
        local threatVel = Vector3.new(threat.velocity.X, 0, threat.velocity.Z)
        if threatVel.Magnitude > 8 then
            local approachDot = threatVel.Unit:Dot(toMe)
            if approachDot > 0.5 and threat.distance < 20 then return true end
            if approachDot > 0.3 and threat.distance < 12 then return true end
        end
        if threat.distance < 8 then return true end
    end
    return false
end

local function FindBestDodgeDirection(hrp, baseDir, threats)
    local hrpPos = hrp.Position
    local bestDir = baseDir
    local bestScore = -999
    for angle = 0, 330, 30 do
        local rad = math.rad(angle)
        local dir = Vector3.new(math.cos(rad), 0, math.sin(rad))
        local score = dir:Dot(baseDir) * 50
        for _, threat in ipairs(threats) do
            local toThreat = threat.hrp.Position - hrpPos
            toThreat = Vector3.new(toThreat.X, 0, toThreat.Z)
            if toThreat.Magnitude > 0.1 then
                score = score - dir:Dot(toThreat.Unit) * 40
            end
            local toPredicted = threat.predictedPos - (hrpPos + dir * 6)
            score = score + math.min(Vector3.new(toPredicted.X, 0, toPredicted.Z).Magnitude, 15) * 2
        end
        if score > bestScore then
            bestScore = score
            bestDir = dir
        end
    end
    return bestDir
end

local function IsNearestPlayerAlsoStealing(hrp)
    local closestDist = math.huge
    local closestPlayer = nil
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            local otherHrp = player.Character:FindFirstChild("HumanoidRootPart")
            if otherHrp then
                local dist = (hrp.Position - otherHrp.Position).Magnitude
                if dist < closestDist then
                    closestDist = dist
                    closestPlayer = player
                end
            end
        end
    end
    if closestPlayer and closestPlayer.Character then
        local otherHum = closestPlayer.Character:FindFirstChild("Humanoid")
        if otherHum and otherHum.WalkSpeed <= 25 then
            return true, closestDist
        end
    end
    return false, closestDist
end

local function IsRagdolled(humanoid)
    local state = humanoid:GetState()
    return state == Enum.HumanoidStateType.Ragdoll 
        or state == Enum.HumanoidStateType.Physics 
        or state == Enum.HumanoidStateType.FallingDown
end

local function IsHit(humanoid, hrp)
    local currentHealth = humanoid.Health
    if currentHealth < LastHealth then
        LastHealth = currentHealth
        return true
    end
    if Vector3.new(hrp.AssemblyLinearVelocity.X, 0, hrp.AssemblyLinearVelocity.Z).Magnitude > 80 then
        return true
    end
    return false
end

pcall(function()
    if game.CoreGui:FindFirstChild("TweenPanel") then
        game.CoreGui:FindFirstChild("TweenPanel"):Destroy()
    end
end)

local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "TweenPanel"
ScreenGui.ResetOnSpawn = false
ScreenGui.Parent = game.CoreGui

local MainFrame = Instance.new("Frame")
MainFrame.Size = UDim2.new(0, 220, 0, 310)
MainFrame.Position = UDim2.new(0.5, -110, 0.5, -155)
MainFrame.BackgroundColor3 = Color3.fromRGB(15, 15, 15)
MainFrame.BorderSizePixel = 0
MainFrame.Active = true
MainFrame.Draggable = true
MainFrame.Parent = ScreenGui
Instance.new("UICorner", MainFrame).CornerRadius = UDim.new(0, 10)
Instance.new("UIStroke", MainFrame).Color = Color3.fromRGB(138, 43, 226)

local Title = Instance.new("TextLabel")
Title.Size = UDim2.new(1, 0, 0, 30)
Title.BackgroundTransparency = 1
Title.Text = "TWEEN PANEL"
Title.TextColor3 = Color3.fromRGB(138, 43, 226)
Title.Font = Enum.Font.GothamBlack
Title.TextSize = 14
Title.Parent = MainFrame

local CloseButton = Instance.new("TextButton")
CloseButton.Size = UDim2.new(0, 25, 0, 25)
CloseButton.Position = UDim2.new(1, -30, 0, 3)
CloseButton.BackgroundTransparency = 1
CloseButton.Text = "X"
CloseButton.TextColor3 = Color3.fromRGB(255, 60, 60)
CloseButton.Font = Enum.Font.GothamBold
CloseButton.TextSize = 14
CloseButton.Parent = MainFrame

local function CreateToggle(parent, text, yPos, defaultState)
    local Container = Instance.new("Frame", parent)
    Container.Size = UDim2.new(1, -20, 0, 28)
    Container.Position = UDim2.new(0, 10, 0, yPos)
    Container.BackgroundTransparency = 1
    local Label = Instance.new("TextLabel", Container)
    Label.Text = text
    Label.Font = Enum.Font.GothamBold
    Label.TextColor3 = Color3.fromRGB(255, 255, 255)
    Label.TextSize = 12
    Label.BackgroundTransparency = 1
    Label.Size = UDim2.new(1, -50, 1, 0)
    Label.TextXAlignment = Enum.TextXAlignment.Left
    local SwitchBg = Instance.new("Frame", Container)
    SwitchBg.Size = UDim2.new(0, 36, 0, 18)
    SwitchBg.Position = UDim2.new(1, -40, 0.5, -9)
    SwitchBg.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    Instance.new("UICorner", SwitchBg).CornerRadius = UDim.new(1, 0)
    local Knob = Instance.new("Frame", SwitchBg)
    Knob.Size = UDim2.new(0, 14, 0, 14)
    Knob.Position = UDim2.new(0, 2, 0.5, -7)
    Knob.BackgroundColor3 = Color3.fromRGB(138, 43, 226)
    Instance.new("UICorner", Knob).CornerRadius = UDim.new(1, 0)
    local toggled = defaultState
    local function updateVisual()
        if toggled then
            Knob.Position = UDim2.new(1, -16, 0.5, -7)
            Knob.BackgroundColor3 = Color3.fromRGB(180, 100, 255)
            SwitchBg.BackgroundColor3 = Color3.fromRGB(100, 50, 150)
        else
            Knob.Position = UDim2.new(0, 2, 0.5, -7)
            Knob.BackgroundColor3 = Color3.fromRGB(138, 43, 226)
            SwitchBg.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
        end
    end
    updateVisual()
    SwitchBg.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            toggled = not toggled
            updateVisual()
        end
    end)
    return function() return toggled end, function(state) toggled = state updateVisual() end
end

local function CreateSlider(parent, text, yPos, minVal, maxVal, defaultVal, suffix)
    local Container = Instance.new("Frame", parent)
    Container.Size = UDim2.new(1, -20, 0, 45)
    Container.Position = UDim2.new(0, 10, 0, yPos)
    Container.BackgroundTransparency = 1
    
    local Label = Instance.new("TextLabel", Container)
    Label.Text = text
    Label.Font = Enum.Font.GothamBold
    Label.TextColor3 = Color3.fromRGB(255, 255, 255)
    Label.TextSize = 11
    Label.BackgroundTransparency = 1
    Label.Size = UDim2.new(0.6, 0, 0, 18)
    Label.Position = UDim2.new(0, 0, 0, 0)
    Label.TextXAlignment = Enum.TextXAlignment.Left
    
    local ValueLabel = Instance.new("TextLabel", Container)
    ValueLabel.Font = Enum.Font.GothamBold
    ValueLabel.TextColor3 = Color3.fromRGB(138, 43, 226)
    ValueLabel.TextSize = 11
    ValueLabel.BackgroundTransparency = 1
    ValueLabel.Size = UDim2.new(0.4, 0, 0, 18)
    ValueLabel.Position = UDim2.new(0.6, 0, 0, 0)
    ValueLabel.TextXAlignment = Enum.TextXAlignment.Right
    ValueLabel.Text = tostring(defaultVal) .. (suffix or "")
    
    local SliderBg = Instance.new("Frame", Container)
    SliderBg.Size = UDim2.new(1, 0, 0, 12)
    SliderBg.Position = UDim2.new(0, 0, 0, 22)
    SliderBg.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    Instance.new("UICorner", SliderBg).CornerRadius = UDim.new(1, 0)
    
    local SliderFill = Instance.new("Frame", SliderBg)
    SliderFill.Size = UDim2.new((defaultVal - minVal) / (maxVal - minVal), 0, 1, 0)
    SliderFill.BackgroundColor3 = Color3.fromRGB(138, 43, 226)
    SliderFill.BorderSizePixel = 0
    Instance.new("UICorner", SliderFill).CornerRadius = UDim.new(1, 0)
    
    local Knob = Instance.new("Frame", SliderBg)
    Knob.Size = UDim2.new(0, 16, 0, 16)
    Knob.Position = UDim2.new((defaultVal - minVal) / (maxVal - minVal), -8, 0.5, -8)
    Knob.BackgroundColor3 = Color3.fromRGB(200, 150, 255)
    Knob.ZIndex = 2
    Instance.new("UICorner", Knob).CornerRadius = UDim.new(1, 0)
    
    local currentValue = defaultVal
    local dragging = false
    
    local function updateSlider(inputPos)
        local relativeX = math.clamp((inputPos.X - SliderBg.AbsolutePosition.X) / SliderBg.AbsoluteSize.X, 0, 1)
        currentValue = math.floor(minVal + (maxVal - minVal) * relativeX)
        SliderFill.Size = UDim2.new(relativeX, 0, 1, 0)
        Knob.Position = UDim2.new(relativeX, -8, 0.5, -8)
        ValueLabel.Text = tostring(currentValue) .. (suffix or "")
    end
    
    SliderBg.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            updateSlider(input.Position)
        end
    end)
    
    Knob.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
        end
    end)
    
    UserInputService.InputChanged:Connect(function(input)
        if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
            updateSlider(input.Position)
        end
    end)
    
    UserInputService.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = false
        end
    end)
    
    return function() return currentValue end, function(val) 
        currentValue = math.clamp(val, minVal, maxVal)
        local relativeX = (currentValue - minVal) / (maxVal - minVal)
        SliderFill.Size = UDim2.new(relativeX, 0, 1, 0)
        Knob.Position = UDim2.new(relativeX, -8, 0.5, -8)
        ValueLabel.Text = tostring(currentValue) .. (suffix or "")
    end
end

local Separator1 = Instance.new("Frame", MainFrame)
Separator1.Size = UDim2.new(1, -20, 0, 1)
Separator1.Position = UDim2.new(0, 10, 0, 32)
Separator1.BackgroundColor3 = Color3.fromRGB(138, 43, 226)

local GetTweenToBrainrot, SetTweenToBrainrot = CreateToggle(MainFrame, "Tween to Brainrot", 38, true)
local GetTweenToBase, SetTweenToBase = CreateToggle(MainFrame, "Tween to Base", 66, true)
local GetSmartDodge, SetSmartDodge = CreateToggle(MainFrame, "Smart Dodge", 94, true)
local GetInstantGrab, SetInstantGrab = CreateToggle(MainFrame, "Instant Grab", 122, true)

local Separator3 = Instance.new("Frame", MainFrame)
Separator3.Size = UDim2.new(1, -20, 0, 1)
Separator3.Position = UDim2.new(0, 10, 0, 152)
Separator3.BackgroundColor3 = Color3.fromRGB(60, 60, 60)

local GetGrabDistance, SetGrabDistance = CreateSlider(MainFrame, "Auto Grab Distance", 158, 5, 200, AUTO_GRAB_DISTANCE, " studs")

local Separator2 = Instance.new("Frame", MainFrame)
Separator2.Size = UDim2.new(1, -20, 0, 1)
Separator2.Position = UDim2.new(0, 10, 0, 208)
Separator2.BackgroundColor3 = Color3.fromRGB(60, 60, 60)

local ProgressLabel = Instance.new("TextLabel")
ProgressLabel.Size = UDim2.new(1, -20, 0, 14)
ProgressLabel.Position = UDim2.new(0, 10, 0, 212)
ProgressLabel.BackgroundTransparency = 1
ProgressLabel.Text = "GRAB PROGRESS"
ProgressLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
ProgressLabel.Font = Enum.Font.GothamBold
ProgressLabel.TextSize = 10
ProgressLabel.TextXAlignment = Enum.TextXAlignment.Left
ProgressLabel.Parent = MainFrame

local ProgressBarBg = Instance.new("Frame")
ProgressBarBg.Size = UDim2.new(1, -20, 0, 12)
ProgressBarBg.Position = UDim2.new(0, 10, 0, 228)
ProgressBarBg.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
ProgressBarBg.BorderSizePixel = 0
ProgressBarBg.Parent = MainFrame
Instance.new("UICorner", ProgressBarBg).CornerRadius = UDim.new(1, 0)

local ProgressBarFill = Instance.new("Frame")
ProgressBarFill.Size = UDim2.new(0, 0, 1, 0)
ProgressBarFill.BackgroundColor3 = Color3.fromRGB(138, 43, 226)
ProgressBarFill.BorderSizePixel = 0
ProgressBarFill.Parent = ProgressBarBg
Instance.new("UICorner", ProgressBarFill).CornerRadius = UDim.new(1, 0)

local FillGradient = Instance.new("UIGradient")
FillGradient.Color = ColorSequence.new({
    ColorSequenceKeypoint.new(0, Color3.fromRGB(138, 43, 226)),
    ColorSequenceKeypoint.new(0.5, Color3.fromRGB(220, 150, 255)),
    ColorSequenceKeypoint.new(1, Color3.fromRGB(138, 43, 226))
})
FillGradient.Parent = ProgressBarFill

local ProgressPercent = Instance.new("TextLabel")
ProgressPercent.Size = UDim2.new(0, 40, 0, 12)
ProgressPercent.Position = UDim2.new(1, -50, 0, 212)
ProgressPercent.BackgroundTransparency = 1
ProgressPercent.Text = "0%"
ProgressPercent.TextColor3 = Color3.fromRGB(255, 255, 255)
ProgressPercent.Font = Enum.Font.GothamBold
ProgressPercent.TextSize = 10
ProgressPercent.TextXAlignment = Enum.TextXAlignment.Right
ProgressPercent.Parent = MainFrame

local PhaseLabel = Instance.new("TextLabel")
PhaseLabel.Size = UDim2.new(1, -20, 0, 18)
PhaseLabel.Position = UDim2.new(0, 10, 0, 246)
PhaseLabel.BackgroundTransparency = 1
PhaseLabel.Text = "Idle [R to Start]"
PhaseLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
PhaseLabel.Font = Enum.Font.GothamBold
PhaseLabel.TextSize = 13
PhaseLabel.TextXAlignment = Enum.TextXAlignment.Center
PhaseLabel.Parent = MainFrame

local StartButton = Instance.new("TextButton")
StartButton.Size = UDim2.new(0.48, 0, 0, 35)
StartButton.Position = UDim2.new(0, 10, 0, 268)
StartButton.BackgroundColor3 = Color3.fromRGB(138, 43, 226)
StartButton.Text = "START [R]"
StartButton.TextColor3 = Color3.fromRGB(255, 255, 255)
StartButton.Font = Enum.Font.GothamBold
StartButton.TextSize = 12
StartButton.Parent = MainFrame
Instance.new("UICorner", StartButton).CornerRadius = UDim.new(0, 8)

local StopButton = Instance.new("TextButton")
StopButton.Size = UDim2.new(0.48, 0, 0, 35)
StopButton.Position = UDim2.new(0.52, 0, 0, 268)
StopButton.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
StopButton.Text = "STOP"
StopButton.TextColor3 = Color3.fromRGB(255, 100, 100)
StopButton.Font = Enum.Font.GothamBold
StopButton.TextSize = 12
StopButton.Parent = MainFrame
Instance.new("UICorner", StopButton).CornerRadius = UDim.new(0, 8)

local function UpdateProgressBar()
    if IsStealing then
        StealProgress = math.clamp((tick() - StealStartTime) / STEAL_DURATION, 0, 1)
        ProgressBarFill.Size = UDim2.new(StealProgress, 0, 1, 0)
        ProgressPercent.Text = math.floor(StealProgress * 100) .. "%"
        if StealProgress >= 1 and not StealFinished then
            finishSteal()
        end
    elseif StealFinished then
        ProgressBarFill.Size = UDim2.new(1, 0, 1, 0)
        ProgressPercent.Text = "100%"
    else
        ProgressBarFill.Size = UDim2.new(0, 0, 1, 0)
        ProgressPercent.Text = "0%"
    end
end

local function ResetGrabAndRecalculate()
    cancelCurrentSteal()
    StealStarted = false
    StealFinished = false
    HasTransitionedToBase = false
    ReachedFinalWaypoint = false
    ProgressBarFill.Size = UDim2.new(0, 0, 1, 0)
    ProgressPercent.Text = "0%"
    PhaseLabel.Text = "HIT! Retrying..."
    PhaseLabel.TextColor3 = Color3.fromRGB(255, 100, 100)
end

local function ForceStop()
    getgenv().TweenPanelRunning = false
    
    IsRunning = false
    IsDodging = false
    cancelCurrentSteal()
    CurrentDodgeDirection = nil
    CurrentPhase = "Idle"
    CurrentWaypointIndex = 1
    AllWaypoints = {}
    ToBaseStartTime = 0
    GrabFinishedTime = 0
    TargetAnimalData = nil
    TotalPathDistance = 0
    HasTransitionedToBase = false
    ReachedFinalWaypoint = false
    ChosenLookDirection = nil
    if Connection then
        pcall(function() Connection:Disconnect() end)
        Connection = nil
    end
    local character = LocalPlayer.Character
    if character then
        local hrp = character:FindFirstChild("HumanoidRootPart")
        if hrp then
            hrp.AssemblyLinearVelocity = Vector3.new(0, hrp.AssemblyLinearVelocity.Y, 0)
        end
    end
    StartButton.Text = "START [R]"
    StartButton.BackgroundColor3 = Color3.fromRGB(138, 43, 226)
    PhaseLabel.Text = "Idle [R to Start]"
    PhaseLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
    ProgressBarFill.Size = UDim2.new(0, 0, 1, 0)
    ProgressPercent.Text = "0%"
end

local function StartTweenToBase()
    local myBase = GetMyAnimalTarget()
    if not myBase then
        ForceStop()
        PhaseLabel.Text = "Stopped (No Base)"
        PhaseLabel.TextColor3 = Color3.fromRGB(255, 100, 100)
        return
    end
    local path = ChooseBasePath(myBase)
    AllWaypoints = {}
    for _, wp in ipairs(path) do
        table.insert(AllWaypoints, wp)
    end
    table.insert(AllWaypoints, myBase)
    CurrentWaypointIndex = 1
    CurrentPhase = "ToBase"
    GrabFinishedTime = tick()
    ToBaseStartTime = tick() + StandStillDuration
    HasTransitionedToBase = true
    PhaseLabel.Text = "Going to Base!"
    PhaseLabel.TextColor3 = Color3.fromRGB(180, 130, 255)
end

local function TryAutoGrab(hrp)
    if not GetInstantGrab() then return false end
    if StealStarted or IsStealing or not TargetAnimalData then return false end
    
    local distanceToTarget = getDistanceToTarget(hrp)
    local grabDistance = GetGrabDistance()
    
    if distanceToTarget <= grabDistance then
        local prompt = findProximityPromptForAnimal(TargetAnimalData)
        if prompt and prompt.Parent then
            StealStarted = true
            local success = executeInstantSteal(prompt)
            if success then
                PhaseLabel.Text = string.format("GRAB @ %.0f studs!", distanceToTarget)
                PhaseLabel.TextColor3 = Color3.fromRGB(0, 255, 100)
                return true
            else
                StealStarted = false
            end
        end
    end
    return false
end

local function StartTween()
    if IsRunning then return end
    
    getgenv().TweenPanelRunning = true
    
    local tb = GetTweenToBrainrot()
    local tbase = GetTweenToBase()
    if not tb and not tbase then
        PhaseLabel.Text = "Nothing selected!"
        PhaseLabel.TextColor3 = Color3.fromRGB(255, 100, 100)
        getgenv().TweenPanelRunning = false
        return
    end
    local character = LocalPlayer.Character
    if not character then 
        getgenv().TweenPanelRunning = false
        return 
    end
    local hrp = character:FindFirstChild("HumanoidRootPart")
    local humanoid = character:FindFirstChild("Humanoid")
    if not hrp or not humanoid then 
        getgenv().TweenPanelRunning = false
        return 
    end
    LastHealth = humanoid.Health
    IsRunning = true
    IsDodging = false
    cancelCurrentSteal()
    CurrentDodgeDirection = nil
    LastDodgeEndTime = 0
    ToBaseStartTime = 0
    GrabFinishedTime = 0
    TargetAnimalData = nil
    TotalPathDistance = 0
    HasTransitionedToBase = false
    ReachedFinalWaypoint = false
    ChosenLookDirection = nil
    StartButton.Text = "RUNNING..."
    StartButton.BackgroundColor3 = Color3.fromRGB(100, 100, 100)
    scanAllPlots()
    prebuildAllCallbacks()
    if tb then
        TargetAnimalData = getBestAnimal()
        if not TargetAnimalData or not TargetAnimalData.worldPosition then
            ForceStop()
            PhaseLabel.Text = "Stopped (No Brainrot)"
            PhaseLabel.TextColor3 = Color3.fromRGB(255, 100, 100)
            return
        end
        local brainrotPos = TargetAnimalData.worldPosition
        local prompt = findProximityPromptForAnimal(TargetAnimalData)
        if prompt then
            buildStealCallbacks(prompt)
        end
        
        local path, finalPath = ChooseBrainrotPath(brainrotPos)
        AllWaypoints = {}
        
        for _, wp in ipairs(path) do
            table.insert(AllWaypoints, wp)
        end
        
        for _, wp in ipairs(finalPath) do
            table.insert(AllWaypoints, wp)
        end
        
        -- SOFORT UMDREHEN WENN R GEDRÃœCKT!
        if ChosenLookDirection then
            SetLookDirection(hrp, ChosenLookDirection)
        end
        
        local startPos = hrp.Position
        for i, wp in ipairs(AllWaypoints) do
            local diff = wp - startPos
            TotalPathDistance = TotalPathDistance + Vector3.new(diff.X, 0, diff.Z).Magnitude
            startPos = wp
        end
        CurrentWaypointIndex = 1
        CurrentPhase = "ToBrainrot"
        PhaseLabel.Text = "Going to Brainrot..."
        PhaseLabel.TextColor3 = Color3.fromRGB(255, 200, 100)
    elseif tbase then
        CurrentPhase = "WaitForSteal"
        PhaseLabel.Text = "Waiting for steal..."
        PhaseLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
    end
    Connection = RunService.Heartbeat:Connect(function()
        if not IsRunning then return end
        local character = LocalPlayer.Character
        if not character then return end
        local hrp = character:FindFirstChild("HumanoidRootPart")
        local humanoid = character:FindFirstChild("Humanoid")
        if not hrp or not humanoid or humanoid.Health <= 0 then return end
        local isStealing = humanoid.WalkSpeed <= 25
        local now = tick()
        local isRagdolled = IsRagdolled(humanoid)
        
        UpdateProgressBar()
        
        if CurrentPhase == "ToBrainrot" and IsStealing then
            if IsHit(humanoid, hrp) then
                ResetGrabAndRecalculate()
                return
            end
        end
        
        if CurrentPhase == "WaitForSteal" then
            if isStealing and GetTweenToBase() then
                StartTweenToBase()
            end
            return
        end
        
        if CurrentPhase == "ToBrainrot" then
            TryAutoGrab(hrp)
            
            if isRagdolled then
                hrp.AssemblyLinearVelocity = Vector3.new(0, math.min(hrp.AssemblyLinearVelocity.Y, 0), 0)
                PhaseLabel.Text = "Ragdolled - Waiting..."
                PhaseLabel.TextColor3 = Color3.fromRGB(255, 150, 50)
                return
            end
            
            if CurrentWaypointIndex > #AllWaypoints then
                ReachedFinalWaypoint = true
                
                if StealFinished and not HasTransitionedToBase then
                    if GetTweenToBase() then
                        StartTweenToBase()
                        return
                    else
                        ForceStop()
                        PhaseLabel.Text = "Grabbed!"
                        PhaseLabel.TextColor3 = Color3.fromRGB(0, 255, 100)
                        return
                    end
                end
                
                if not StealFinished then
                    PhaseLabel.Text = "At Brainrot - Waiting..."
                    PhaseLabel.TextColor3 = Color3.fromRGB(255, 200, 100)
                end
                return
            end
            
            local target = AllWaypoints[CurrentWaypointIndex]
            local diff = target - hrp.Position
            local flatDiff = Vector3.new(diff.X, 0, diff.Z)
            local distance = flatDiff.Magnitude
            
            local isLastWaypoint = CurrentWaypointIndex == #AllWaypoints
            local reachDist = isLastWaypoint and FINAL_WAYPOINT_REACH_DIST or WAYPOINT_REACH_DIST
            
            if distance < reachDist then
                CurrentWaypointIndex = CurrentWaypointIndex + 1
                return
            end
            
            local moveDir = flatDiff.Unit
            hrp.AssemblyLinearVelocity = Vector3.new(moveDir.X * TweenToSpeed, hrp.AssemblyLinearVelocity.Y, moveDir.Z * TweenToSpeed)
            return
        end
        
        if CurrentPhase == "ToBase" then
            if isRagdolled then
                hrp.AssemblyLinearVelocity = Vector3.new(0, math.min(hrp.AssemblyLinearVelocity.Y, 0), 0)
                PhaseLabel.Text = "Ragdolled - Waiting..."
                PhaseLabel.TextColor3 = Color3.fromRGB(255, 150, 50)
                return
            end
            
            local wasHit = IsHit(humanoid, hrp)
            if wasHit then
                ForceStop()
                PhaseLabel.Text = "Stopped (Hit)"
                PhaseLabel.TextColor3 = Color3.fromRGB(255, 100, 100)
                return
            end
            
            local timeSinceGrab = now - GrabFinishedTime
            if timeSinceGrab < StandStillDuration then
                hrp.AssemblyLinearVelocity = Vector3.new(0, hrp.AssemblyLinearVelocity.Y, 0)
                PhaseLabel.Text = "Starting..."
                PhaseLabel.TextColor3 = Color3.fromRGB(255, 200, 100)
                return
            end
            
            if CurrentWaypointIndex > #AllWaypoints then
                ForceStop()
                PhaseLabel.Text = "Complete!"
                PhaseLabel.TextColor3 = Color3.fromRGB(100, 255, 100)
                return
            end
            
            local target = AllWaypoints[CurrentWaypointIndex]
            local diff = target - hrp.Position
            local flatDiff = Vector3.new(diff.X, 0, diff.Z)
            local distance = flatDiff.Magnitude
            
            if distance < 4 then
                CurrentWaypointIndex = CurrentWaypointIndex + 1
                return
            end
            
            local moveDir = flatDiff.Unit
            local finalDir = moveDir
            local timeSinceStart = now - ToBaseStartTime
            local finalSpeed
            
            if timeSinceStart < SlowSpeedDuration then
                finalSpeed = WalkSpeedSlow
            else
                finalSpeed = WalkSpeed
            end
            
            local canDodgeYet = timeSinceStart >= DodgeStartDelay
            local opponentAlsoStealing, opponentDist = IsNearestPlayerAlsoStealing(hrp)
            local isRaceMode = opponentAlsoStealing and opponentDist < 50
            local smartDodgeEnabled = GetSmartDodge() and canDodgeYet and not isRaceMode
            
            if smartDodgeEnabled then
                if IsDodging then
                    local dodgeElapsed = now - DodgeStartTime
                    if dodgeElapsed < DodgeDuration then
                        finalDir = CurrentDodgeDirection
                        finalSpeed = DodgeSpeed
                        PhaseLabel.Text = "DODGING!"
                        PhaseLabel.TextColor3 = Color3.fromRGB(255, 50, 50)
                    else
                        IsDodging = false
                        CurrentDodgeDirection = nil
                        LastDodgeEndTime = now
                        PhaseLabel.Text = "Going to Base..."
                        PhaseLabel.TextColor3 = Color3.fromRGB(180, 130, 255)
                    end
                else
                    local canDodge = (now - LastDodgeEndTime) > DodgeCooldown
                    if canDodge then
                        local threats = GetAllThreats(hrp)
                        if ShouldDodge(hrp, threats) then
                            IsDodging = true
                            DodgeStartTime = now
                            CurrentDodgeDirection = FindBestDodgeDirection(hrp, moveDir, threats)
                            finalDir = CurrentDodgeDirection
                            finalSpeed = DodgeSpeed
                            PhaseLabel.Text = "DODGING!"
                            PhaseLabel.TextColor3 = Color3.fromRGB(255, 50, 50)
                        end
                    end
                end
            elseif isRaceMode then
                PhaseLabel.Text = "RACE MODE!"
                PhaseLabel.TextColor3 = Color3.fromRGB(255, 200, 0)
            else
                PhaseLabel.Text = "Going to Base..."
                PhaseLabel.TextColor3 = Color3.fromRGB(180, 130, 255)
            end
            
            hrp.AssemblyLinearVelocity = Vector3.new(finalDir.X * finalSpeed, hrp.AssemblyLinearVelocity.Y, finalDir.Z * finalSpeed)
        end
    end)
end

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.KeyCode == Enum.KeyCode.R then
        if IsRunning then ForceStop() else StartTween() end
    end
end)

StartButton.MouseButton1Click:Connect(function()
    if IsRunning then ForceStop() else StartTween() end
end)

StopButton.MouseButton1Click:Connect(function()
    ForceStop()
end)

CloseButton.MouseButton1Click:Connect(function()
    ForceStop()
    ScreenGui:Destroy()
end)

LocalPlayer.CharacterAdded:Connect(function()
    ForceStop()
    LastHealth = 100
end)

task.spawn(function()
    task.wait(0.5)
    scanAllPlots()
    prebuildAllCallbacks()
    while true do
        task.wait(3)
        scanAllPlots()
        prebuildAllCallbacks()
    end
end)
