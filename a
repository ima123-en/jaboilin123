local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local UserInputService = game:GetService("UserInputService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local PhysicsService = game:GetService("PhysicsService")
local LocalPlayer = Players.LocalPlayer

local Packages = ReplicatedStorage:WaitForChild("Packages")
local Datas = ReplicatedStorage:WaitForChild("Datas")
local Shared = ReplicatedStorage:WaitForChild("Shared")
local Utils = ReplicatedStorage:WaitForChild("Utils")

local Synchronizer = require(Packages:WaitForChild("Synchronizer"))
local AnimalsData = require(Datas:WaitForChild("Animals"))
local AnimalsShared = require(Shared:WaitForChild("Animals"))
local NumberUtils = require(Utils:WaitForChild("NumberUtils"))

-- ========================================
-- NEUE DIREKTE SPEED BOOST LOGIK
-- ========================================
local SpeedBoostEnabled = true
local TargetSpeed = 58.5  -- Ground Speed
local AirSpeed = 58.5     -- Air Speed (GLEICH!)

local TweenToSpeed = 59
local VELOCITY_LERP_ALPHA = 0.7
local WalkSpeed = 29.7
local WalkSpeedSlow = 29
local SlowSpeedDuration = 0.4
local StandStillDuration = -1
local DodgeSpeed = 29
local DodgeRadius = 28
local DodgeDuration = 0.22
local DodgeCooldown = 0.8
local DodgeStartDelay = 0.6
local DodgePredictionTime = 0.4
local STEAL_DURATION = 0.5
local GRAB_DISTANCE = 21
local WAYPOINT_REACH_DIST = 4
local FINAL_WAYPOINT_REACH_DIST = 1.5
local PROGRESS_CAP = 0.90
local TP_DELAY = 0.25

local TpAfterRagdollEnabled = false
local LastRagdollTime = 0
local RagdollCooldown = 0.5
local WasRagdolledLastFrame = false
local JustTeleported = false
local AllowTpAfterRagdoll = true

local IsRunning = false
local IsDodging = false
local DodgeStartTime = 0
local LastDodgeEndTime = 0
local CurrentDodgeDirection = nil
local LastHealth = 100
local Connection = nil
local ToBaseStartTime = 0
local GrabFinishedTime = 0
local CurrentPhase = "Idle"
local CurrentWaypointIndex = 1
local AllWaypoints = {}
local IsStealing = false
local StealProgress = 0
local StealStartTime = 0
local StealStarted = false
local StealFinished = false
local StealFinishTime = 0
local CurrentStealPrompt = nil
local InternalStealCache = {}
local PromptMemoryCache = {}
local allAnimalsCache = {}
local plotChannels = {}
local lastAnimalData = {}
local TargetAnimalData = nil
local TotalPathDistance = 0
local HasTransitionedToBase = false
local ReachedFinalWaypoint = false

local CycleStartTime = 0
local LastCycleTime = 0
local BestCycleTime = math.huge

local SafeTPPoint = Vector3.new(-475.60, -7.30, 57.68)

local NoCollisionActive = false
local NoCollisionConnection = nil

local IsDragging = false

local BrainrotPath1 = {
    Vector3.new(-476.48, -6.28, 92.73),
    Vector3.new(-483.12, -4.95, 94.80),
}

local BrainrotPath2 = {
    Vector3.new(-476.16, -6.52, 25.62),
    Vector3.new(-483.04, -5.09, 23.14),
}

local FinalPath1 = {
    Vector3.new(-483.12, -4.95, 94.80)
}

local FinalPath2 = {
    Vector3.new(-483.04, -5.09, 23.14)
}

local BasePath1 = {
    Vector3.new(-474.480, -7.098, 95.407),
    Vector3.new(-473.165, -7.098, 22.341),
}

local BasePath2 = {
    Vector3.new(-472.409, -7.098, 25.268),
    Vector3.new(-472.676, -7.098, 98.162),
}

-- ========================================
-- GROUND CHECK FUNKTION
-- ========================================
local function IsGrounded(hrp)
    local rayParams = RaycastParams.new()
    rayParams.FilterDescendantsInstances = {LocalPlayer.Character}
    local result = Workspace:Raycast(hrp.Position, Vector3.new(0, -3.5, 0), rayParams)
    return result ~= nil
end

-- ========================================
-- NEUE DIREKTE SPEED BOOST FUNKTION
-- ========================================
local function ApplySpeedBoost(hrp, moveDir)
    if not SpeedBoostEnabled then return 0 end
    
    if moveDir.Magnitude < 0.1 then 
        return 0
    end
    
    -- Check if grounded
    local grounded = IsGrounded(hrp)
    
    -- WÃ„HLE SPEED: Ground oder Air
    local targetSpeed = grounded and TargetSpeed or AirSpeed
    
    -- ========================================
    -- DIREKTES SETZEN - KEINE LERP-LIMITS!
    -- ========================================
    local currentVel = hrp.AssemblyLinearVelocity
    local newVel = moveDir.Unit * targetSpeed
    hrp.AssemblyLinearVelocity = Vector3.new(newVel.X, currentVel.Y, newVel.Z)
    
    return targetSpeed
end

local function ResetSpeedBoost()
    -- Nichts zu resetten bei direktem Speed
end

local function NukeAllPlayerCollisions()
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            for _, part in ipairs(player.Character:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = false
                    part.CanTouch = false
                end
            end
        end
    end
    local myChar = LocalPlayer.Character
    if myChar then
        for _, part in ipairs(myChar:GetDescendants()) do
            if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
                part.CanCollide = false
            end
        end
    end
end

local function StartNoCollision()
    if NoCollisionActive then return end
    NoCollisionActive = true
    NukeAllPlayerCollisions()
    NoCollisionConnection = RunService.Heartbeat:Connect(function()
        if not NoCollisionActive then return end
        NukeAllPlayerCollisions()
    end)
end

local function StopNoCollision(delay)
    task.delay(delay or 0, function()
        NoCollisionActive = false
        if NoCollisionConnection then
            NoCollisionConnection:Disconnect()
            NoCollisionConnection = nil
        end
    end)
end

local function SetVelocity(hrp, moveDir, speed)
    local currentVel = hrp.AssemblyLinearVelocity
    local targetVel = Vector3.new(moveDir.X * speed, currentVel.Y, moveDir.Z * speed)
    hrp.AssemblyLinearVelocity = currentVel:Lerp(targetVel, VELOCITY_LERP_ALPHA)
end

local function SetVelocityWithSpeedBoost(hrp, moveDir)
    return ApplySpeedBoost(hrp, moveDir)
end

local function StopMovement(hrp)
    hrp.AssemblyLinearVelocity = Vector3.new(0, hrp.AssemblyLinearVelocity.Y, 0)
end

local function getHRP()
    local char = LocalPlayer.Character
    if not char then return nil end
    return char:FindFirstChild("HumanoidRootPart")
end

local function IsPathClear(fromPos, toPos)
    local rayParams = RaycastParams.new()
    rayParams.FilterType = Enum.RaycastFilterType.Exclude
    local filterList = {LocalPlayer.Character}
    for _, player in ipairs(Players:GetPlayers()) do
        if player.Character then
            table.insert(filterList, player.Character)
        end
    end
    rayParams.FilterDescendantsInstances = filterList
    local direction = toPos - fromPos
    local result = Workspace:Raycast(fromPos, direction, rayParams)
    if result then
        local hitPart = result.Instance
        if hitPart and hitPart:IsA("BasePart") then
            if hitPart.CanCollide and hitPart.Transparency < 0.9 then
                local distanceToHit = (result.Position - fromPos).Magnitude
                local totalDistance = direction.Magnitude
                if distanceToHit < totalDistance - 1 then
                    return false, result.Position
                end
            end
        end
    end
    return true, nil
end

local function FindSafeTeleportPoint(currentPos, targetPos)
    if IsPathClear(currentPos, SafeTPPoint) then
        return SafeTPPoint
    end
    local midPoint = Vector3.new(-475.60, -7.30, 57.68)
    if IsPathClear(currentPos, midPoint) then
        return midPoint
    end
    local safePoints = {
        Vector3.new(-470, -7.30, 57.68),
        Vector3.new(-465, -7.30, 57.68),
        Vector3.new(-475.60, -7.30, 70),
        Vector3.new(-475.60, -7.30, 45),
    }
    for _, point in ipairs(safePoints) do
        if IsPathClear(currentPos, point) then
            return point
        end
    end
    return currentPos
end

local function GetBestTeleportPath(currentPos, finalTarget)
    local path = {}
    local clearToTarget, _ = IsPathClear(currentPos, finalTarget)
    if clearToTarget then
        table.insert(path, finalTarget)
        return path
    end
    local safePoint = FindSafeTeleportPoint(currentPos, finalTarget)
    if safePoint ~= currentPos then
        table.insert(path, safePoint)
    end
    local clearFromSafe, _ = IsPathClear(safePoint, finalTarget)
    if clearFromSafe then
        table.insert(path, finalTarget)
    end
    return path
end

local function SafeTeleport(hrp, targetPos)
    StartNoCollision()
    NukeAllPlayerCollisions()
    task.wait()
    NukeAllPlayerCollisions()
    hrp.CFrame = CFrame.new(targetPos)
    hrp.AssemblyLinearVelocity = Vector3.zero
    hrp.AssemblyAngularVelocity = Vector3.zero
    task.wait()
    NukeAllPlayerCollisions()
    hrp.CFrame = CFrame.new(targetPos)
    hrp.AssemblyLinearVelocity = Vector3.zero
    hrp.AssemblyAngularVelocity = Vector3.zero
    StopNoCollision(1)
end

local function isMyBase(plotName)
    local plots = Workspace:FindFirstChild("Plots")
    if not plots then return false end
    local plot = plots:FindFirstChild(plotName)
    if not plot then return false end
    local channel = Synchronizer:Get(plot.Name)
    if channel then
        local owner = channel:Get("Owner")
        if owner then
            if typeof(owner) == "Instance" and owner:IsA("Player") then
                return owner.UserId == LocalPlayer.UserId
            elseif typeof(owner) == "table" and owner.UserId then
                return owner.UserId == LocalPlayer.UserId
            end
        end
    end
    local sign = plot:FindFirstChild("PlotSign")
    if sign then
        local yourBase = sign:FindFirstChild("YourBase")
        if yourBase and yourBase:IsA("BillboardGui") then
            return yourBase.Enabled == true
        end
    end
    return false
end

local function GetMyPlot()
    local plots = Workspace:FindFirstChild("Plots")
    if not plots then return nil end
    for _, plot in pairs(plots:GetChildren()) do
        if isMyBase(plot.Name) then
            return plot
        end
    end
    return nil
end

local function getAnimalHash(animalList)
    if not animalList then return "" end
    local hash = ""
    for slot, data in pairs(animalList) do
        if type(data) == "table" then
            hash = hash .. tostring(slot) .. tostring(data.Index) .. tostring(data.Mutation)
        end
    end
    return hash
end

local function scanSinglePlot(plot)
    pcall(function()
        local plotUID = plot.Name
        if isMyBase(plotUID) then return end
        local channel = Synchronizer:Get(plotUID)
        if not channel then return end
        local animalList = channel:Get("AnimalList")
        local currentHash = getAnimalHash(animalList)
        if lastAnimalData[plotUID] == currentHash then return end
        lastAnimalData[plotUID] = currentHash
        for i = #allAnimalsCache, 1, -1 do
            if allAnimalsCache[i].plot == plot.Name then
                table.remove(allAnimalsCache, i)
            end
        end
        local owner = channel:Get("Owner")
        if not owner or not Players:FindFirstChild(owner.Name) then return end
        local ownerName = owner and owner.Name or "Unknown"
        if not animalList then return end
        for slot, animalData in pairs(animalList) do
            if type(animalData) == "table" then
                local animalName = animalData.Index
                local animalInfo = AnimalsData[animalName]
                if not animalInfo then continue end
                local mutation = animalData.Mutation or "None"
                local genValue = AnimalsShared:GetGeneration(animalName, animalData.Mutation, animalData.Traits, nil)
                local podiums = plot:FindFirstChild("AnimalPodiums")
                local worldPos = nil
                if podiums then
                    local podium = podiums:FindFirstChild(tostring(slot))
                    if podium then
                        worldPos = podium:GetPivot().Position
                    end
                end
                table.insert(allAnimalsCache, {
                    name = animalInfo.DisplayName or animalName,
                    genValue = genValue,
                    mutation = mutation,
                    owner = ownerName,
                    plot = plot.Name,
                    slot = tostring(slot),
                    uid = plot.Name .. "_" .. tostring(slot),
                    worldPosition = worldPos,
                })
            end
        end
        table.sort(allAnimalsCache, function(a, b)
            return a.genValue > b.genValue
        end)
    end)
end

local function scanAllPlots()
    local plots = Workspace:FindFirstChild("Plots")
    if not plots then return end
    for _, plot in ipairs(plots:GetChildren()) do
        scanSinglePlot(plot)
    end
end

local function findProximityPromptForAnimal(animalData)
    if not animalData then return nil end
    local cachedPrompt = PromptMemoryCache[animalData.uid]
    if cachedPrompt and cachedPrompt.Parent then
        return cachedPrompt
    end
    local plot = Workspace.Plots:FindFirstChild(animalData.plot)
    if not plot then return nil end
    local podiums = plot:FindFirstChild("AnimalPodiums")
    if not podiums then return nil end
    local podium = podiums:FindFirstChild(animalData.slot)
    if not podium then return nil end
    local base = podium:FindFirstChild("Base")
    if not base then return nil end
    local spawn = base:FindFirstChild("Spawn")
    if not spawn then return nil end
    local attach = spawn:FindFirstChild("PromptAttachment")
    if not attach then return nil end
    for _, p in ipairs(attach:GetChildren()) do
        if p:IsA("ProximityPrompt") then
            PromptMemoryCache[animalData.uid] = p
            return p
        end
    end
    return nil
end

local function buildStealCallbacks(prompt)
    if InternalStealCache[prompt] then return true end
    local data = {
        holdCallbacks = {},
        triggerCallbacks = {},
        ready = true,
    }
    local ok1, conns1 = pcall(getconnections, prompt.PromptButtonHoldBegan)
    if ok1 and type(conns1) == "table" then
        for _, conn in ipairs(conns1) do
            if type(conn.Function) == "function" then
                table.insert(data.holdCallbacks, conn.Function)
            end
        end
    end
    local ok2, conns2 = pcall(getconnections, prompt.Triggered)
    if ok2 and type(conns2) == "table" then
        for _, conn in ipairs(conns2) do
            if type(conn.Function) == "function" then
                table.insert(data.triggerCallbacks, conn.Function)
            end
        end
    end
    if (#data.holdCallbacks > 0) or (#data.triggerCallbacks > 0) then
        InternalStealCache[prompt] = data
        return true
    end
    return false
end

local function prebuildAllCallbacks()
    for _, animalData in ipairs(allAnimalsCache) do
        local prompt = findProximityPromptForAnimal(animalData)
        if prompt then
            buildStealCallbacks(prompt)
        end
    end
end

local function cancelCurrentSteal()
    if CurrentStealPrompt and InternalStealCache[CurrentStealPrompt] then
        InternalStealCache[CurrentStealPrompt].ready = true
    end
    IsStealing = false
    StealProgress = 0
    StealStarted = false
    StealFinished = false
    StealStartTime = 0
    StealFinishTime = 0
    CurrentStealPrompt = nil
end

local function executeInstantSteal(prompt)
    if not prompt or not prompt.Parent then return false end
    if not buildStealCallbacks(prompt) then return false end
    local data = InternalStealCache[prompt]
    if not data or not data.ready then return false end
    data.ready = false
    IsStealing = true
    StealProgress = 0
    StealStartTime = tick()
    StealFinished = false
    CurrentStealPrompt = prompt
    if #data.holdCallbacks > 0 then
        for _, fn in ipairs(data.holdCallbacks) do
            task.spawn(fn)
        end
    end
    return true
end

local function finishSteal()
    if not CurrentStealPrompt then return end
    if StealFinished then return end
    local data = InternalStealCache[CurrentStealPrompt]
    if not data then return end
    if #data.triggerCallbacks > 0 then
        for _, fn in ipairs(data.triggerCallbacks) do
            task.spawn(fn)
        end
    end
    StealFinished = true
    StealFinishTime = tick()
    task.delay(0.05, function()
        if data then data.ready = true end
    end)
    task.delay(0.1, function()
        IsStealing = false
        StealProgress = 0
        CurrentStealPrompt = nil
    end)
end

local function getBestAnimal()
    if #allAnimalsCache == 0 then return nil end
    for _, animal in ipairs(allAnimalsCache) do
        if not isMyBase(animal.plot) then
            return animal
        end
    end
    return nil
end

local function getDistanceToTarget(hrp)
    if not TargetAnimalData or not TargetAnimalData.worldPosition then return math.huge end
    local diff = TargetAnimalData.worldPosition - hrp.Position
    return Vector3.new(diff.X, 0, diff.Z).Magnitude
end

local function getDistanceToPrompt(hrp)
    if not TargetAnimalData then return math.huge end
    local prompt = findProximityPromptForAnimal(TargetAnimalData)
    if not prompt or not prompt.Parent then return math.huge end
    local attachment = prompt.Parent
    if not attachment or not attachment:IsA("Attachment") then return math.huge end
    local part = attachment.Parent
    if not part or not part:IsA("BasePart") then return math.huge end
    local promptWorldPos = part.CFrame:PointToWorldSpace(attachment.Position)
    local diff = promptWorldPos - hrp.Position
    return diff.Magnitude
end

local function GetMyAnimalTarget()
    local myPlot = GetMyPlot()
    if not myPlot then return nil end
    local animalTarget = myPlot:FindFirstChild("AnimalTarget")
    if animalTarget and animalTarget:IsA("BasePart") then
        return animalTarget.Position
    end
    return nil
end

local function ChooseBrainrotPath(brainrotPos)
    if not brainrotPos then return BrainrotPath1, FinalPath1 end
    local dist1 = (BrainrotPath1[#BrainrotPath1] - brainrotPos).Magnitude
    local dist2 = (BrainrotPath2[#BrainrotPath2] - brainrotPos).Magnitude
    if dist1 < dist2 then
        return BrainrotPath1, FinalPath1
    else
        return BrainrotPath2, FinalPath2
    end
end

local function ChooseBasePath(basePos)
    if not basePos then return BasePath1 end
    local dist1 = (BasePath1[#BasePath1] - basePos).Magnitude
    local dist2 = (BasePath2[#BasePath2] - basePos).Magnitude
    return dist1 < dist2 and BasePath1 or BasePath2
end

local function GetAllThreats(hrp)
    local threats = {}
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            local otherHrp = player.Character:FindFirstChild("HumanoidRootPart")
            if otherHrp then
                local distance = (hrp.Position - otherHrp.Position).Magnitude
                if distance <= DodgeRadius then
                    local vel = otherHrp.AssemblyLinearVelocity
                    table.insert(threats, {
                        hrp = otherHrp,
                        distance = distance,
                        velocity = vel,
                        predictedPos = otherHrp.Position + Vector3.new(vel.X, 0, vel.Z) * DodgePredictionTime,
                    })
                end
            end
        end
    end
    return threats
end

local function ShouldDodge(hrp, threats)
    for _, threat in ipairs(threats) do
        local toMe = hrp.Position - threat.hrp.Position
        toMe = Vector3.new(toMe.X, 0, toMe.Z)
        if toMe.Magnitude < 0.1 then continue end
        toMe = toMe.Unit
        local threatVel = Vector3.new(threat.velocity.X, 0, threat.velocity.Z)
        if threatVel.Magnitude > 8 then
            local approachDot = threatVel.Unit:Dot(toMe)
            if approachDot > 0.5 and threat.distance < 20 then return true end
            if approachDot > 0.3 and threat.distance < 12 then return true end
        end
        if threat.distance < 8 then return true end
    end
    return false
end

local function FindBestDodgeDirection(hrp, baseDir, threats)
    local hrpPos = hrp.Position
    local bestDir = baseDir
    local bestScore = -999
    for angle = 0, 330, 30 do
        local rad = math.rad(angle)
        local dir = Vector3.new(math.cos(rad), 0, math.sin(rad))
        local score = dir:Dot(baseDir) * 50
        for _, threat in ipairs(threats) do
            local toThreat = threat.hrp.Position - hrpPos
            toThreat = Vector3.new(toThreat.X, 0, toThreat.Z)
            if toThreat.Magnitude > 0.1 then
                score = score - dir:Dot(toThreat.Unit) * 40
            end
            local toPredicted = threat.predictedPos - (hrpPos + dir * 6)
            score = score + math.min(Vector3.new(toPredicted.X, 0, toPredicted.Z).Magnitude, 15) * 2
        end
        if score > bestScore then
            bestScore = score
            bestDir = dir
        end
    end
    return bestDir
end

local function IsNearestPlayerAlsoStealing(hrp)
    local closestDist = math.huge
    local closestPlayer = nil
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            local otherHrp = player.Character:FindFirstChild("HumanoidRootPart")
            if otherHrp then
                local dist = (hrp.Position - otherHrp.Position).Magnitude
                if dist < closestDist then
                    closestDist = dist
                    closestPlayer = player
                end
            end
        end
    end
    if closestPlayer and closestPlayer.Character then
        local otherHum = closestPlayer.Character:FindFirstChild("Humanoid")
        if otherHum and otherHum.WalkSpeed <= 25 then
            return true, closestDist
        end
    end
    return false, closestDist
end

local function IsRagdolled(humanoid)
    local state = humanoid:GetState()
    return state == Enum.HumanoidStateType.Ragdoll
        or state == Enum.HumanoidStateType.Physics
        or state == Enum.HumanoidStateType.FallingDown
end

local function IsHit(humanoid, hrp)
    local currentHealth = humanoid.Health
    if currentHealth < LastHealth then
        LastHealth = currentHealth
        return true
    end
    if Vector3.new(hrp.AssemblyLinearVelocity.X, 0, hrp.AssemblyLinearVelocity.Z).Magnitude > 80 then
        return true
    end
    return false
end

local function CleanRagdoll(character)
    for _, desc in pairs(character:GetDescendants()) do
        if desc:IsA("BallSocketConstraint") or desc:IsA("NoCollisionConstraint") or desc:IsA("HingeConstraint") then
            pcall(function() desc:Destroy() end)
        elseif desc:IsA("Motor6D") then
            pcall(function() desc.Enabled = true end)
        end
    end
end

local function ForceStop()
    IsRunning = false
    IsDodging = false
    cancelCurrentSteal()
    CurrentDodgeDirection = nil
    CurrentPhase = "Idle"
    CurrentWaypointIndex = 1
    AllWaypoints = {}
    ToBaseStartTime = 0
    GrabFinishedTime = 0
    TargetAnimalData = nil
    TotalPathDistance = 0
    HasTransitionedToBase = false
    ReachedFinalWaypoint = false
    CycleStartTime = 0
    JustTeleported = false
    ResetSpeedBoost()
    getgenv().TweenPanelRunning = false
    StopNoCollision(0)
    if Connection then
        Connection:Disconnect()
        Connection = nil
    end
    local character = LocalPlayer.Character
    if character then
        local hrp = character:FindFirstChild("HumanoidRootPart")
        if hrp then
            StopMovement(hrp)
        end
    end
end

pcall(function()
    if game.CoreGui:FindFirstChild("TweenPanel") then
        game.CoreGui:FindFirstChild("TweenPanel"):Destroy()
    end
end)

local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "TweenPanel"
ScreenGui.ResetOnSpawn = false
ScreenGui.Parent = game.CoreGui

local MainFrame = Instance.new("Frame")
MainFrame.Size = UDim2.new(0, 220, 0, 450)
MainFrame.Position = UDim2.new(0.5, -110, 0.5, -225)
MainFrame.BackgroundColor3 = Color3.fromRGB(15, 15, 15)
MainFrame.BorderSizePixel = 0
MainFrame.Active = true
MainFrame.Parent = ScreenGui
Instance.new("UICorner", MainFrame).CornerRadius = UDim.new(0, 10)
Instance.new("UIStroke", MainFrame).Color = Color3.fromRGB(138, 43, 226)

local DragBar = Instance.new("Frame")
DragBar.Size = UDim2.new(1, 0, 0, 30)
DragBar.BackgroundTransparency = 1
DragBar.Parent = MainFrame

local Title = Instance.new("TextLabel")
Title.Size = UDim2.new(1, 0, 0, 30)
Title.BackgroundTransparency = 1
Title.Text = "TWEEN PANEL - DIRECT"
Title.TextColor3 = Color3.fromRGB(138, 43, 226)
Title.Font = Enum.Font.GothamBlack
Title.TextSize = 14
Title.Parent = MainFrame

local CloseButton = Instance.new("TextButton")
CloseButton.Size = UDim2.new(0, 25, 0, 25)
CloseButton.Position = UDim2.new(1, -30, 0, 3)
CloseButton.BackgroundTransparency = 1
CloseButton.Text = "X"
CloseButton.TextColor3 = Color3.fromRGB(255, 60, 60)
CloseButton.Font = Enum.Font.GothamBold
CloseButton.TextSize = 14
CloseButton.Parent = MainFrame

local dragStart = nil
local startPos = nil

DragBar.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        IsDragging = true
        dragStart = input.Position
        startPos = MainFrame.Position
        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                IsDragging = false
            end
        end)
    end
end)

UserInputService.InputChanged:Connect(function(input)
    if IsDragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
        local delta = input.Position - dragStart
        MainFrame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
    end
end)

local function CreateToggle(parent, text, yPos, defaultState)
    local Container = Instance.new("Frame", parent)
    Container.Size = UDim2.new(1, -20, 0, 28)
    Container.Position = UDim2.new(0, 10, 0, yPos)
    Container.BackgroundTransparency = 1
    local Label = Instance.new("TextLabel", Container)
    Label.Text = text
    Label.Font = Enum.Font.GothamBold
    Label.TextColor3 = Color3.fromRGB(255, 255, 255)
    Label.TextSize = 12
    Label.BackgroundTransparency = 1
    Label.Size = UDim2.new(1, -50, 1, 0)
    Label.TextXAlignment = Enum.TextXAlignment.Left
    local SwitchBg = Instance.new("Frame", Container)
    SwitchBg.Size = UDim2.new(0, 36, 0, 18)
    SwitchBg.Position = UDim2.new(1, -40, 0.5, -9)
    SwitchBg.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    Instance.new("UICorner", SwitchBg).CornerRadius = UDim.new(1, 0)
    local Knob = Instance.new("Frame", SwitchBg)
    Knob.Size = UDim2.new(0, 14, 0, 14)
    Knob.Position = UDim2.new(0, 2, 0.5, -7)
    Knob.BackgroundColor3 = Color3.fromRGB(138, 43, 226)
    Instance.new("UICorner", Knob).CornerRadius = UDim.new(1, 0)
    local toggled = defaultState
    local function updateVisual()
        if toggled then
            Knob.Position = UDim2.new(1, -16, 0.5, -7)
            Knob.BackgroundColor3 = Color3.fromRGB(180, 100, 255)
            SwitchBg.BackgroundColor3 = Color3.fromRGB(100, 50, 150)
        else
            Knob.Position = UDim2.new(0, 2, 0.5, -7)
            Knob.BackgroundColor3 = Color3.fromRGB(138, 43, 226)
            SwitchBg.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
        end
    end
    updateVisual()
    SwitchBg.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            toggled = not toggled
            updateVisual()
        end
    end)
    return function() return toggled end, function(state) toggled = state updateVisual() end
end

local Separator1 = Instance.new("Frame", MainFrame)
Separator1.Size = UDim2.new(1, -20, 0, 1)
Separator1.Position = UDim2.new(0, 10, 0, 32)
Separator1.BackgroundColor3 = Color3.fromRGB(138, 43, 226)

local GetTweenToBrainrot, SetTweenToBrainrot = CreateToggle(MainFrame, "Tween to Brainrot", 38, true)
local GetTweenToBase, SetTweenToBase = CreateToggle(MainFrame, "Tween to Base", 66, true)
local GetSmartDodge, SetSmartDodge = CreateToggle(MainFrame, "Smart Dodge", 94, true)
local GetInstantGrab, SetInstantGrab = CreateToggle(MainFrame, "Instant Grab", 122, true)

local Separator4 = Instance.new("Frame", MainFrame)
Separator4.Size = UDim2.new(1, -20, 0, 1)
Separator4.Position = UDim2.new(0, 10, 0, 152)
Separator4.BackgroundColor3 = Color3.fromRGB(60, 60, 60)

local GetTpAfterRagdoll, SetTpAfterRagdoll = CreateToggle(MainFrame, "TP After Ragdoll", 158, false)

local Separator2 = Instance.new("Frame", MainFrame)
Separator2.Size = UDim2.new(1, -20, 0, 1)
Separator2.Position = UDim2.new(0, 10, 0, 190)
Separator2.BackgroundColor3 = Color3.fromRGB(60, 60, 60)

-- ========================================
-- SPEED SETTINGS
-- ========================================
local SpeedSettingsLabel = Instance.new("TextLabel")
SpeedSettingsLabel.Size = UDim2.new(1, -20, 0, 14)
SpeedSettingsLabel.Position = UDim2.new(0, 10, 0, 196)
SpeedSettingsLabel.BackgroundTransparency = 1
SpeedSettingsLabel.Text = "SPEED SETTINGS"
SpeedSettingsLabel.TextColor3 = Color3.fromRGB(138, 43, 226)
SpeedSettingsLabel.Font = Enum.Font.GothamBold
SpeedSettingsLabel.TextSize = 10
SpeedSettingsLabel.TextXAlignment = Enum.TextXAlignment.Left
SpeedSettingsLabel.Parent = MainFrame

local SpeedInputFrame = Instance.new("Frame")
SpeedInputFrame.Size = UDim2.new(1, -20, 0, 24)
SpeedInputFrame.Position = UDim2.new(0, 10, 0, 212)
SpeedInputFrame.BackgroundTransparency = 1
SpeedInputFrame.Parent = MainFrame

local GroundLabel = Instance.new("TextLabel", SpeedInputFrame)
GroundLabel.Size = UDim2.new(0, 45, 1, 0)
GroundLabel.Position = UDim2.new(0, 0, 0, 0)
GroundLabel.BackgroundTransparency = 1
GroundLabel.Text = "Ground"
GroundLabel.TextColor3 = Color3.fromRGB(100, 255, 100)
GroundLabel.Font = Enum.Font.GothamBold
GroundLabel.TextSize = 10
GroundLabel.TextXAlignment = Enum.TextXAlignment.Left

local GroundSpeedBox = Instance.new("TextBox", SpeedInputFrame)
GroundSpeedBox.Size = UDim2.new(0, 45, 0, 20)
GroundSpeedBox.Position = UDim2.new(0, 48, 0, 2)
GroundSpeedBox.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
GroundSpeedBox.Text = tostring(TargetSpeed)
GroundSpeedBox.TextColor3 = Color3.fromRGB(255, 255, 255)
GroundSpeedBox.Font = Enum.Font.Gotham
GroundSpeedBox.TextSize = 11
GroundSpeedBox.ClearTextOnFocus = false
Instance.new("UICorner", GroundSpeedBox).CornerRadius = UDim.new(0, 4)

local AirLabel = Instance.new("TextLabel", SpeedInputFrame)
AirLabel.Size = UDim2.new(0, 25, 1, 0)
AirLabel.Position = UDim2.new(0, 100, 0, 0)
AirLabel.BackgroundTransparency = 1
AirLabel.Text = "Air"
AirLabel.TextColor3 = Color3.fromRGB(100, 200, 255)
AirLabel.Font = Enum.Font.GothamBold
AirLabel.TextSize = 10
AirLabel.TextXAlignment = Enum.TextXAlignment.Left

local AirSpeedBox = Instance.new("TextBox", SpeedInputFrame)
AirSpeedBox.Size = UDim2.new(0, 45, 0, 20)
AirSpeedBox.Position = UDim2.new(0, 128, 0, 2)
AirSpeedBox.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
AirSpeedBox.Text = tostring(AirSpeed)
AirSpeedBox.TextColor3 = Color3.fromRGB(255, 255, 255)
AirSpeedBox.Font = Enum.Font.Gotham
AirSpeedBox.TextSize = 11
AirSpeedBox.ClearTextOnFocus = false
Instance.new("UICorner", AirSpeedBox).CornerRadius = UDim.new(0, 4)

GroundSpeedBox.FocusLost:Connect(function()
    local num = tonumber(GroundSpeedBox.Text)
    if num and num > 0 then
        TargetSpeed = num
    else
        GroundSpeedBox.Text = tostring(TargetSpeed)
    end
end)

AirSpeedBox.FocusLost:Connect(function()
    local num = tonumber(AirSpeedBox.Text)
    if num and num > 0 then
        AirSpeed = num
    else
        AirSpeedBox.Text = tostring(AirSpeed)
    end
end)

local Separator5 = Instance.new("Frame", MainFrame)
Separator5.Size = UDim2.new(1, -20, 0, 1)
Separator5.Position = UDim2.new(0, 10, 0, 242)
Separator5.BackgroundColor3 = Color3.fromRGB(60, 60, 60)

local ProgressLabel = Instance.new("TextLabel")
ProgressLabel.Size = UDim2.new(1, -20, 0, 14)
ProgressLabel.Position = UDim2.new(0, 10, 0, 248)
ProgressLabel.BackgroundTransparency = 1
ProgressLabel.Text = "GRAB PROGRESS"
ProgressLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
ProgressLabel.Font = Enum.Font.GothamBold
ProgressLabel.TextSize = 10
ProgressLabel.TextXAlignment = Enum.TextXAlignment.Left
ProgressLabel.Parent = MainFrame

local ProgressBarBg = Instance.new("Frame")
ProgressBarBg.Size = UDim2.new(1, -20, 0, 12)
ProgressBarBg.Position = UDim2.new(0, 10, 0, 264)
ProgressBarBg.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
ProgressBarBg.BorderSizePixel = 0
ProgressBarBg.Parent = MainFrame
Instance.new("UICorner", ProgressBarBg).CornerRadius = UDim.new(1, 0)

local ProgressBarFill = Instance.new("Frame")
ProgressBarFill.Size = UDim2.new(0, 0, 1, 0)
ProgressBarFill.BackgroundColor3 = Color3.fromRGB(138, 43, 226)
ProgressBarFill.BorderSizePixel = 0
ProgressBarFill.Parent = ProgressBarBg
Instance.new("UICorner", ProgressBarFill).CornerRadius = UDim.new(1, 0)

local FillGradient = Instance.new("UIGradient")
FillGradient.Color = ColorSequence.new({
    ColorSequenceKeypoint.new(0, Color3.fromRGB(138, 43, 226)),
    ColorSequenceKeypoint.new(0.5, Color3.fromRGB(220, 150, 255)),
    ColorSequenceKeypoint.new(1, Color3.fromRGB(138, 43, 226))
})
FillGradient.Parent = ProgressBarFill

local ProgressPercent = Instance.new("TextLabel")
ProgressPercent.Size = UDim2.new(0, 40, 0, 12)
ProgressPercent.Position = UDim2.new(1, -50, 0, 248)
ProgressPercent.BackgroundTransparency = 1
ProgressPercent.Text = "0%"
ProgressPercent.TextColor3 = Color3.fromRGB(255, 255, 255)
ProgressPercent.Font = Enum.Font.GothamBold
ProgressPercent.TextSize = 10
ProgressPercent.TextXAlignment = Enum.TextXAlignment.Right
ProgressPercent.Parent = MainFrame

local PhaseLabel = Instance.new("TextLabel")
PhaseLabel.Size = UDim2.new(1, -20, 0, 18)
PhaseLabel.Position = UDim2.new(0, 10, 0, 282)
PhaseLabel.BackgroundTransparency = 1
PhaseLabel.Text = "Idle [R to Start]"
PhaseLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
PhaseLabel.Font = Enum.Font.GothamBold
PhaseLabel.TextSize = 13
PhaseLabel.TextXAlignment = Enum.TextXAlignment.Center
PhaseLabel.Parent = MainFrame

local DebugLabel = Instance.new("TextLabel")
DebugLabel.Size = UDim2.new(1, -20, 0, 14)
DebugLabel.Position = UDim2.new(0, 10, 0, 302)
DebugLabel.BackgroundTransparency = 1
DebugLabel.Text = ""
DebugLabel.TextColor3 = Color3.fromRGB(100, 100, 100)
DebugLabel.Font = Enum.Font.Gotham
DebugLabel.TextSize = 9
DebugLabel.TextXAlignment = Enum.TextXAlignment.Center
DebugLabel.Parent = MainFrame

local StartButton = Instance.new("TextButton")
StartButton.Size = UDim2.new(0.48, 0, 0, 35)
StartButton.Position = UDim2.new(0, 10, 0, 322)
StartButton.BackgroundColor3 = Color3.fromRGB(138, 43, 226)
StartButton.Text = "START [R]"
StartButton.TextColor3 = Color3.fromRGB(255, 255, 255)
StartButton.Font = Enum.Font.GothamBold
StartButton.TextSize = 12
StartButton.Parent = MainFrame
Instance.new("UICorner", StartButton).CornerRadius = UDim.new(0, 8)

local StopButton = Instance.new("TextButton")
StopButton.Size = UDim2.new(0.48, 0, 0, 35)
StopButton.Position = UDim2.new(0.52, 0, 0, 322)
StopButton.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
StopButton.Text = "STOP"
StopButton.TextColor3 = Color3.fromRGB(255, 100, 100)
StopButton.Font = Enum.Font.GothamBold
StopButton.TextSize = 12
StopButton.Parent = MainFrame
Instance.new("UICorner", StopButton).CornerRadius = UDim.new(0, 8)

local TimerFrame = Instance.new("Frame")
TimerFrame.Size = UDim2.new(1, -20, 0, 28)
TimerFrame.Position = UDim2.new(0, 10, 0, 367)
TimerFrame.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
TimerFrame.BorderSizePixel = 0
TimerFrame.Parent = MainFrame
Instance.new("UICorner", TimerFrame).CornerRadius = UDim.new(0, 6)

local CurrentTimeLabel = Instance.new("TextLabel")
CurrentTimeLabel.Size = UDim2.new(0.5, 0, 1, 0)
CurrentTimeLabel.Position = UDim2.new(0, 5, 0, 0)
CurrentTimeLabel.BackgroundTransparency = 1
CurrentTimeLabel.Text = "â± 0.00s"
CurrentTimeLabel.TextColor3 = Color3.fromRGB(255, 200, 100)
CurrentTimeLabel.Font = Enum.Font.GothamBold
CurrentTimeLabel.TextSize = 11
CurrentTimeLabel.TextXAlignment = Enum.TextXAlignment.Left
CurrentTimeLabel.Parent = TimerFrame

local BestTimeLabel = Instance.new("TextLabel")
BestTimeLabel.Size = UDim2.new(0.5, 0, 1, 0)
BestTimeLabel.Position = UDim2.new(0.5, -5, 0, 0)
BestTimeLabel.BackgroundTransparency = 1
BestTimeLabel.Text = "ðŸ† --"
BestTimeLabel.TextColor3 = Color3.fromRGB(100, 255, 100)
BestTimeLabel.Font = Enum.Font.GothamBold
BestTimeLabel.TextSize = 11
BestTimeLabel.TextXAlignment = Enum.TextXAlignment.Right
BestTimeLabel.Parent = TimerFrame

local SpeedStatusFrame = Instance.new("Frame")
SpeedStatusFrame.Size = UDim2.new(1, -20, 0, 32)
SpeedStatusFrame.Position = UDim2.new(0, 10, 0, 402)
SpeedStatusFrame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
SpeedStatusFrame.BorderSizePixel = 0
SpeedStatusFrame.Parent = MainFrame
Instance.new("UICorner", SpeedStatusFrame).CornerRadius = UDim.new(0, 6)
Instance.new("UIStroke", SpeedStatusFrame).Color = Color3.fromRGB(80, 80, 80)

local SpeedStatusLabel = Instance.new("TextLabel")
SpeedStatusLabel.Size = UDim2.new(1, -10, 1, 0)
SpeedStatusLabel.Position = UDim2.new(0, 5, 0, 0)
SpeedStatusLabel.BackgroundTransparency = 1
SpeedStatusLabel.Text = "DIRECT - GROUND - 59.5"
SpeedStatusLabel.TextColor3 = Color3.fromRGB(100, 255, 100)
SpeedStatusLabel.Font = Enum.Font.GothamBlack
SpeedStatusLabel.TextSize = 11
SpeedStatusLabel.TextXAlignment = Enum.TextXAlignment.Center
SpeedStatusLabel.Parent = SpeedStatusFrame

local function UpdateTimer()
    if CycleStartTime > 0 and IsRunning then
        local elapsed = tick() - CycleStartTime
        CurrentTimeLabel.Text = string.format("â± %.2fs", elapsed)
    end
end

local function UpdateSpeedStatus(speed, grounded)
    if IsRunning and CurrentPhase == "ToBrainrot" then
        local mode = grounded and "GROUND" or "AIR"
        SpeedStatusLabel.Text = string.format("DIRECT - %s - %.1f", mode, speed)
        if grounded then
            SpeedStatusLabel.TextColor3 = Color3.fromRGB(100, 255, 100)
        else
            SpeedStatusLabel.TextColor3 = Color3.fromRGB(100, 200, 255)
        end
    else
        SpeedStatusLabel.Text = "DIRECT - IDLE"
        SpeedStatusLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
    end
end

local function UpdateProgressBar()
    local activeProgress = 0
    local isActive = false
    if IsStealing and not StealFinished then
        local rawProgress = math.clamp((tick() - StealStartTime) / STEAL_DURATION, 0, 1)
        StealProgress = rawProgress
        activeProgress = math.min(rawProgress, PROGRESS_CAP)
        isActive = true
        if rawProgress >= 1 and not StealFinished then
            finishSteal()
        end
    elseif StealFinished then
        activeProgress = PROGRESS_CAP
        isActive = true
    end
    if isActive then
        ProgressBarFill.Size = UDim2.new(activeProgress, 0, 1, 0)
        ProgressPercent.Text = math.floor(activeProgress * 100) .. "%"
    else
        ProgressBarFill.Size = UDim2.new(0, 0, 1, 0)
        ProgressPercent.Text = "0%"
    end
    UpdateTimer()
end

local function ResetGrabAndRecalculate()
    cancelCurrentSteal()
    StealStarted = false
    StealFinished = false
    HasTransitionedToBase = false
    ReachedFinalWaypoint = false
    ProgressBarFill.Size = UDim2.new(0, 0, 1, 0)
    ProgressPercent.Text = "0%"
    PhaseLabel.Text = "HIT! Retrying..."
    PhaseLabel.TextColor3 = Color3.fromRGB(255, 100, 100)
end

local function FinishCycle()
    if CycleStartTime > 0 then
        LastCycleTime = tick() - CycleStartTime
        if LastCycleTime < BestCycleTime then
            BestCycleTime = LastCycleTime
            BestTimeLabel.Text = string.format("ðŸ† %.2fs", BestCycleTime)
            BestTimeLabel.TextColor3 = Color3.fromRGB(0, 255, 100)
        end
        CurrentTimeLabel.Text = string.format("â± %.2fs", LastCycleTime)
        CycleStartTime = 0
    end
end

local function ForceStopFull()
    ForceStop()
    StartButton.Text = "START [R]"
    StartButton.BackgroundColor3 = Color3.fromRGB(138, 43, 226)
    PhaseLabel.Text = "Idle [R to Start]"
    PhaseLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
    DebugLabel.Text = ""
    ProgressBarFill.Size = UDim2.new(0, 0, 1, 0)
    ProgressPercent.Text = "0%"
    UpdateSpeedStatus(0, true)
end

local function StartTweenToBase()
    local myBase = GetMyAnimalTarget()
    if not myBase then
        FinishCycle()
        ForceStopFull()
        PhaseLabel.Text = "Stopped (No Base)"
        PhaseLabel.TextColor3 = Color3.fromRGB(255, 100, 100)
        return
    end
    local path = ChooseBasePath(myBase)
    AllWaypoints = {}
    for _, wp in ipairs(path) do
        table.insert(AllWaypoints, wp)
    end
    table.insert(AllWaypoints, myBase)
    CurrentWaypointIndex = 1
    CurrentPhase = "ToBase"
    GrabFinishedTime = tick()
    ToBaseStartTime = tick() + StandStillDuration
    HasTransitionedToBase = true
    PhaseLabel.Text = "Going to Base!"
    PhaseLabel.TextColor3 = Color3.fromRGB(180, 130, 255)
end

local function TryAutoGrab(hrp)
    if not GetInstantGrab() then return false end
    if StealStarted or IsStealing or not TargetAnimalData then return false end
    local distanceToTarget = getDistanceToTarget(hrp)
    local promptDist = getDistanceToPrompt(hrp)
    if distanceToTarget <= GRAB_DISTANCE or promptDist <= GRAB_DISTANCE then
        local prompt = findProximityPromptForAnimal(TargetAnimalData)
        if prompt and prompt.Parent then
            StealStarted = true
            local success = executeInstantSteal(prompt)
            if success then
                local usedDist = math.min(distanceToTarget, promptDist)
                PhaseLabel.Text = string.format("GRAB @ %.0f studs!", usedDist)
                PhaseLabel.TextColor3 = Color3.fromRGB(0, 255, 100)
                return true
            else
                StealStarted = false
            end
        end
    end
    return false
end

local function StartTween()
    if IsRunning then return end
    CycleStartTime = tick()
    ResetSpeedBoost()
    local tb = GetTweenToBrainrot()
    local tbase = GetTweenToBase()
    if not tb and not tbase then
        PhaseLabel.Text = "Nothing selected!"
        PhaseLabel.TextColor3 = Color3.fromRGB(255, 100, 100)
        CycleStartTime = 0
        return
    end
    local character = LocalPlayer.Character
    if not character then CycleStartTime = 0 return end
    local hrp = character:FindFirstChild("HumanoidRootPart")
    local humanoid = character:FindFirstChild("Humanoid")
    if not hrp or not humanoid then CycleStartTime = 0 return end
    LastHealth = humanoid.Health
    IsRunning = true
    getgenv().TweenPanelRunning = true
    IsDodging = false
    cancelCurrentSteal()
    CurrentDodgeDirection = nil
    LastDodgeEndTime = 0
    ToBaseStartTime = 0
    GrabFinishedTime = 0
    TargetAnimalData = nil
    TotalPathDistance = 0
    HasTransitionedToBase = false
    ReachedFinalWaypoint = false
    StartButton.Text = "RUNNING..."
    StartButton.BackgroundColor3 = Color3.fromRGB(100, 100, 100)
    scanAllPlots()
    prebuildAllCallbacks()
    if tb then
        TargetAnimalData = getBestAnimal()
        if not TargetAnimalData or not TargetAnimalData.worldPosition then
            FinishCycle()
            ForceStopFull()
            PhaseLabel.Text = "Stopped (No Brainrot)"
            PhaseLabel.TextColor3 = Color3.fromRGB(255, 100, 100)
            return
        end
        local brainrotPos = TargetAnimalData.worldPosition
        local prompt = findProximityPromptForAnimal(TargetAnimalData)
        if prompt then
            buildStealCallbacks(prompt)
        end
        local path, finalPath = ChooseBrainrotPath(brainrotPos)
        AllWaypoints = {}
        for _, wp in ipairs(path) do
            table.insert(AllWaypoints, wp)
        end
        for _, wp in ipairs(finalPath) do
            table.insert(AllWaypoints, wp)
        end
        table.insert(AllWaypoints, brainrotPos)
        local startPos = hrp.Position
        TotalPathDistance = 0
        for i, wp in ipairs(AllWaypoints) do
            local diff = wp - startPos
            TotalPathDistance = TotalPathDistance + Vector3.new(diff.X, 0, diff.Z).Magnitude
            startPos = wp
        end
        CurrentWaypointIndex = 1
        if JustTeleported then
            CurrentWaypointIndex = 2
            JustTeleported = false
        end
        CurrentPhase = "ToBrainrot"
        PhaseLabel.Text = "Going to Brainrot..."
        PhaseLabel.TextColor3 = Color3.fromRGB(255, 200, 100)
        DebugLabel.Text = string.format("Path: %.0f studs | %d waypoints", TotalPathDistance, #AllWaypoints)
    elseif tbase then
        CurrentPhase = "WaitForSteal"
        PhaseLabel.Text = "Waiting for steal..."
        PhaseLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
    end
    Connection = RunService.Heartbeat:Connect(function()
        if not IsRunning then return end
        local character = LocalPlayer.Character
        if not character then return end
        local hrp = character:FindFirstChild("HumanoidRootPart")
        local humanoid = character:FindFirstChild("Humanoid")
        if not hrp or not humanoid or humanoid.Health <= 0 then return end
        local isStealing = humanoid.WalkSpeed <= 25
        local now = tick()
        local isRagdolled = IsRagdolled(humanoid)
        local grounded = IsGrounded(hrp)
        UpdateProgressBar()
        if CurrentPhase == "ToBrainrot" and IsStealing then
            if IsHit(humanoid, hrp) then
                ResetGrabAndRecalculate()
                return
            end
        end
        if CurrentPhase == "WaitForSteal" then
            if isStealing and GetTweenToBase() then
                StartTweenToBase()
            end
            UpdateSpeedStatus(0, true)
            return
        end
        if CurrentPhase == "ToBrainrot" then
            TryAutoGrab(hrp)
            if isRagdolled then
                StopMovement(hrp)
                PhaseLabel.Text = "Ragdolled - Waiting..."
                PhaseLabel.TextColor3 = Color3.fromRGB(255, 150, 50)
                UpdateSpeedStatus(0, grounded)
                return
            end
            if CurrentWaypointIndex > #AllWaypoints then
                ReachedFinalWaypoint = true
                StopMovement(hrp)
                UpdateSpeedStatus(0, grounded)
                if StealFinished and not HasTransitionedToBase then
                    if GetTweenToBase() then
                        StartTweenToBase()
                        return
                    else
                        FinishCycle()
                        ForceStopFull()
                        PhaseLabel.Text = "Grabbed!"
                        PhaseLabel.TextColor3 = Color3.fromRGB(0, 255, 100)
                        return
                    end
                end
                if not StealFinished and not StealStarted then
                    local prompt = findProximityPromptForAnimal(TargetAnimalData)
                    if prompt and prompt.Parent then
                        StealStarted = true
                        local success = executeInstantSteal(prompt)
                        if success then
                            PhaseLabel.Text = "LATE GRAB!"
                            PhaseLabel.TextColor3 = Color3.fromRGB(255, 150, 0)
                        else
                            StealStarted = false
                            PhaseLabel.Text = "Grab failed - too far?"
                            PhaseLabel.TextColor3 = Color3.fromRGB(255, 50, 50)
                        end
                    end
                end
                if not StealFinished then
                    PhaseLabel.Text = "At Brainrot - Waiting..."
                    PhaseLabel.TextColor3 = Color3.fromRGB(255, 200, 100)
                end
                return
            end
            local target = AllWaypoints[CurrentWaypointIndex]
            local diff = target - hrp.Position
            local flatDiff = Vector3.new(diff.X, 0, diff.Z)
            local distance = flatDiff.Magnitude
            local isLastWaypoint = CurrentWaypointIndex == #AllWaypoints
            local reachDist = isLastWaypoint and FINAL_WAYPOINT_REACH_DIST or WAYPOINT_REACH_DIST
            if distance < reachDist then
                CurrentWaypointIndex = CurrentWaypointIndex + 1
                return
            end
            local moveDir = flatDiff.Unit
            local currentSpeed = SetVelocityWithSpeedBoost(hrp, moveDir)
            UpdateSpeedStatus(currentSpeed, grounded)
            local distToAnimal = getDistanceToTarget(hrp)
            local distToPrompt = getDistanceToPrompt(hrp)
            DebugLabel.Text = string.format("WP:%d/%d | Ani:%.0f | Prm:%.0f", CurrentWaypointIndex, #AllWaypoints, distToAnimal, distToPrompt)
            return
        end
        if CurrentPhase == "ToBase" then
            UpdateSpeedStatus(0, grounded)
            if isRagdolled then
                StopMovement(hrp)
                PhaseLabel.Text = "Ragdolled - Waiting..."
                PhaseLabel.TextColor3 = Color3.fromRGB(255, 150, 50)
                return
            end
            local wasHit = IsHit(humanoid, hrp)
            if wasHit then
                FinishCycle()
                ForceStopFull()
                PhaseLabel.Text = "Stopped (Hit)"
                PhaseLabel.TextColor3 = Color3.fromRGB(255, 100, 100)
                return
            end
            local timeSinceGrab = now - GrabFinishedTime
            if timeSinceGrab < StandStillDuration then
                StopMovement(hrp)
                PhaseLabel.Text = "Starting..."
                PhaseLabel.TextColor3 = Color3.fromRGB(255, 200, 100)
                return
            end
            if CurrentWaypointIndex > #AllWaypoints then
                FinishCycle()
                ForceStopFull()
                PhaseLabel.Text = "Complete!"
                PhaseLabel.TextColor3 = Color3.fromRGB(100, 255, 100)
                return
            end
            local target = AllWaypoints[CurrentWaypointIndex]
            local diff = target - hrp.Position
            local flatDiff = Vector3.new(diff.X, 0, diff.Z)
            local distance = flatDiff.Magnitude
            if distance < 4 then
                CurrentWaypointIndex = CurrentWaypointIndex + 1
                return
            end
            local moveDir = flatDiff.Unit
            local finalDir = moveDir
            local timeSinceStart = now - ToBaseStartTime
            local finalSpeed
            if timeSinceStart < SlowSpeedDuration then
                finalSpeed = WalkSpeedSlow
            else
                finalSpeed = WalkSpeed
            end
            local canDodgeYet = timeSinceStart >= DodgeStartDelay
            local opponentAlsoStealing, opponentDist = IsNearestPlayerAlsoStealing(hrp)
            local isRaceMode = opponentAlsoStealing and opponentDist < 50
            local smartDodgeEnabled = GetSmartDodge() and canDodgeYet and not isRaceMode
            if smartDodgeEnabled then
                if IsDodging then
                    local dodgeElapsed = now - DodgeStartTime
                    if dodgeElapsed < DodgeDuration then
                        finalDir = CurrentDodgeDirection
                        finalSpeed = DodgeSpeed
                        PhaseLabel.Text = "DODGING!"
                        PhaseLabel.TextColor3 = Color3.fromRGB(255, 50, 50)
                    else
                        IsDodging = false
                        CurrentDodgeDirection = nil
                        LastDodgeEndTime = now
                        PhaseLabel.Text = "Going to Base..."
                        PhaseLabel.TextColor3 = Color3.fromRGB(180, 130, 255)
                    end
                else
                    local canDodge = (now - LastDodgeEndTime) > DodgeCooldown
                    if canDodge then
                        local threats = GetAllThreats(hrp)
                        if ShouldDodge(hrp, threats) then
                            IsDodging = true
                            DodgeStartTime = now
                            CurrentDodgeDirection = FindBestDodgeDirection(hrp, moveDir, threats)
                            finalDir = CurrentDodgeDirection
                            finalSpeed = DodgeSpeed
                            PhaseLabel.Text = "DODGING!"
                            PhaseLabel.TextColor3 = Color3.fromRGB(255, 50, 50)
                        end
                    end
                end
            elseif isRaceMode then
                PhaseLabel.Text = "RACE MODE!"
                PhaseLabel.TextColor3 = Color3.fromRGB(255, 200, 0)
            else
                PhaseLabel.Text = "Going to Base..."
                PhaseLabel.TextColor3 = Color3.fromRGB(180, 130, 255)
            end
            SetVelocity(hrp, finalDir, finalSpeed)
        end
    end)
end

local function TeleportToPathAndRun()
    if not TpAfterRagdollEnabled then return end
    if not AllowTpAfterRagdoll then return end
    if IsRunning then return end
    local now = tick()
    if now - LastRagdollTime < RagdollCooldown then return end
    LastRagdollTime = now
    local character = LocalPlayer.Character
    if not character then return end
    local hrp = character:FindFirstChild("HumanoidRootPart")
    local humanoid = character:FindFirstChild("Humanoid")
    if not hrp or not humanoid then return end
    StartNoCollision()
    task.wait(TP_DELAY)
    character = LocalPlayer.Character
    if not character then StopNoCollision(0) return end
    hrp = character:FindFirstChild("HumanoidRootPart")
    humanoid = character:FindFirstChild("Humanoid")
    if not hrp or not humanoid then StopNoCollision(0) return end
    CleanRagdoll(character)
    pcall(function() humanoid:ChangeState(Enum.HumanoidStateType.GettingUp) end)
    task.wait(0.05)
    CleanRagdoll(character)
    pcall(function() humanoid:ChangeState(Enum.HumanoidStateType.Running) end)
    scanAllPlots()
    local bestAnimal = getBestAnimal()
    if not bestAnimal or not bestAnimal.worldPosition then
        if GetTweenToBase() then
            local myBase = GetMyAnimalTarget()
            if myBase then
                local basePath = ChooseBasePath(myBase)
                local tpPoint = basePath[1]
                local currentPos = hrp.Position
                local pathClear = IsPathClear(currentPos, tpPoint)
                if pathClear then
                    SafeTeleport(hrp, tpPoint)
                else
                    local safePath = GetBestTeleportPath(currentPos, tpPoint)
                    if #safePath > 0 then
                        SafeTeleport(hrp, safePath[1])
                    end
                end
                task.wait(0.05)
                CleanRagdoll(character)
                pcall(function() humanoid:ChangeState(Enum.HumanoidStateType.Running) end)
            end
        end
        StopNoCollision(0.5)
        return
    end
    local brainrotPos = bestAnimal.worldPosition
    local path, finalPath = ChooseBrainrotPath(brainrotPos)
    local tpPoint = path[1]
    local currentPos = hrp.Position
    local pathClear = IsPathClear(currentPos, tpPoint)
    if pathClear then
        SafeTeleport(hrp, tpPoint)
    else
        local safePath = GetBestTeleportPath(currentPos, tpPoint)
        if #safePath > 0 then
            for i, point in ipairs(safePath) do
                SafeTeleport(hrp, point)
                if i < #safePath then
                    task.wait(0.08)
                    CleanRagdoll(character)
                end
            end
        else
            SafeTeleport(hrp, SafeTPPoint)
        end
    end
    task.wait(0.05)
    CleanRagdoll(character)
    pcall(function() humanoid:ChangeState(Enum.HumanoidStateType.Running) end)
    JustTeleported = true
    StopNoCollision(0.5)
    if GetTweenToBrainrot() and not IsRunning then
        task.defer(StartTween)
    end
end

local function ToggleScript()
    if IsRunning then
        ForceStopFull()
    else
        StartTween()
    end
end

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if IsDragging then return end
    if input.KeyCode == Enum.KeyCode.R then
        ToggleScript()
    end
end)

StartButton.MouseButton1Click:Connect(function()
    if not IsDragging then
        ToggleScript()
    end
end)

StopButton.MouseButton1Click:Connect(function()
    if not IsDragging then
        ForceStopFull()
    end
end)

CloseButton.MouseButton1Click:Connect(function()
    ForceStopFull()
    ScreenGui:Destroy()
end)

RunService.Heartbeat:Connect(function()
    TpAfterRagdollEnabled = GetTpAfterRagdoll()
    local character = LocalPlayer.Character
    if not character then return end
    local humanoid = character:FindFirstChild("Humanoid")
    if not humanoid then return end
    local isNowRagdolled = IsRagdolled(humanoid)
    if WasRagdolledLastFrame and not isNowRagdolled then
        if TpAfterRagdollEnabled and AllowTpAfterRagdoll and not IsRunning then
            task.spawn(TeleportToPathAndRun)
        end
    end
    WasRagdolledLastFrame = isNowRagdolled
end)

task.spawn(function()
    while task.wait(0.03) do
        if IsStealing then
            UpdateProgressBar()
        end
    end
end)

LocalPlayer.CharacterAdded:Connect(function(character)
    task.wait(1)
    ForceStopFull()
    LastHealth = 100
    LastRagdollTime = 0
    WasRagdolledLastFrame = false
    JustTeleported = false
    AllowTpAfterRagdoll = false
    ResetSpeedBoost()
    task.wait(1.5)
    AllowTpAfterRagdoll = true
end)

task.spawn(function()
    task.wait(0.5)
    scanAllPlots()
    prebuildAllCallbacks()
    while true do
        task.wait(3)
        scanAllPlots()
        prebuildAllCallbacks()
    end
end)

AllowTpAfterRagdoll = true
